{"ast":null,"code":"var _regeneratorRuntime = require(\"/home/hayden/workplace/dapp-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/hayden/workplace/dapp-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar axios = require(\"axios\");\n\nvar Promise = require('promise');\n\nvar txDecoder = require('ethereum-tx-decoder');\n\nvar _require = require('./config'),\n    config = _require.config,\n    RESPONSE_CODES = _require.RESPONSE_CODES,\n    EVENTS = _require.EVENTS,\n    BICONOMY_RESPONSE_CODES = _require.BICONOMY_RESPONSE_CODES,\n    STATUS = _require.STATUS;\n\nvar DEFAULT_PAYLOAD_ID = \"99999999\";\n\nvar Web3 = require('web3');\n\nvar baseURL = config.baseURL;\nvar userLoginPath = config.userLoginPath;\nvar withdrawFundsUrl = config.withdrawFundsUrl;\nvar getUserContractPath = config.getUserContractPath;\nvar JSON_RPC_VERSION = config.JSON_RPC_VERSION;\nvar USER_ACCOUNT = config.USER_ACCOUNT;\nvar USER_CONTRACT = config.USER_CONTRACT;\nvar NATIVE_META_TX_URL = config.nativeMetaTxUrl;\nvar decoderMap = {},\n    smartContractMap = {};\nvar web3;\n\nvar events = require('events');\n\nvar eventEmitter = new events.EventEmitter();\nvar loginInterval;\nvar domainType, metaInfoType, relayerPaymentType, metaTransactionType;\nvar domainData = {\n  name: config.eip712DomainName,\n  version: config.eip712SigVersion,\n  verifyingContract: config.eip712VerifyingContract\n}; // EIP712 format data for login\n\nvar loginDomainType, loginMessageType, loginDomainData;\n\nfunction Biconomy(provider, options) {\n  _validate(options);\n\n  this.status = STATUS.INIT;\n  this.dappId = options.dappId;\n  this.apiKey = options.apiKey;\n  this.isLogin = false;\n  this.dappAPIMap = {};\n  this.strictMode = options.strictMode || false;\n  this.providerId = options.providerId || 0;\n  this.readViaContract = options.readViaContract || false;\n  this.READY = STATUS.BICONOMY_READY;\n  this.LOGIN_CONFIRMATION = EVENTS.LOGIN_CONFIRMATION;\n  this.ERROR = EVENTS.BICONOMY_ERROR;\n  this.pendingLoginTransactions = {};\n\n  if (options.debug) {\n    config.logsEnabled = true;\n  }\n\n  _init(this.dappId, this.apiKey, this);\n\n  if (provider) {\n    web3 = new Web3(provider);\n\n    if (options.defaultAccount) {\n      web3.eth.defaultAccount = options.defaultAccount;\n    }\n\n    var proto = Object.getPrototypeOf(provider);\n    var keys = Object.getOwnPropertyNames(proto);\n\n    for (var i = 0; i < keys.length; i++) {\n      this[keys[i]] = provider[keys[i]];\n    }\n\n    for (var key in provider) {\n      if (!this[key]) {\n        this[key] = provider[key];\n      }\n    }\n\n    this.providerSend = provider.send || provider.sendAsync;\n\n    this.send = function (payload, cb) {\n      if (payload.method == 'eth_sendTransaction') {\n        handleSendTransaction(this, payload, function (error, result) {\n          var response = _createJsonRpcResponse(payload, error, result);\n\n          if (cb) {\n            cb(error, response);\n          }\n        });\n      } else if (payload.method == 'eth_sendRawTransaction') {\n        sendSignedTransaction(this, payload, function (error, result) {\n          var response = _createJsonRpcResponse(payload, error, result);\n\n          if (cb) {\n            cb(error, response);\n          }\n        });\n      } else if (payload.method == 'eth_call') {\n        var userContract = getFromStorage(USER_CONTRACT);\n\n        if (this.readViaContract && this.isLogin && userContract) {\n          if (payload && payload.params && payload.params[0]) {\n            payload.params[0].from = userContract;\n          }\n        }\n\n        web3.currentProvider.send(payload, cb);\n      } else {\n        web3.currentProvider.send(payload, cb);\n      }\n    };\n\n    this.sendAsync = this.send;\n  } else {\n    throw new Error('Please pass a provider to Biconomy.');\n  }\n}\n/**\n * This method returns an EIP712 formatted data ready to be signed\n * that will be used in login method/API.\n * LoginMessageType [\n * \t { name: \"userAddress\", type: \"address\"},\n *   { name: \"nonce\", type: \"uint256\"},\n *   { name: \"providerId\", type: \"string\"}\n * ]\n */\n\n\nBiconomy.prototype.getLoginMessageToSign = function (signer) {\n  var _this = this;\n\n  var engine = this;\n  return new Promise( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {\n      var response, message, nonce, dataToSign;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n\n              if (!(!signer || typeof signer != 'string')) {\n                _context.next = 4;\n                break;\n              }\n\n              response = formatMessage(RESPONSE_CODES.INVALID_DATA, \"signer parameter is mandatory and should be of type 'string'\");\n              return _context.abrupt(\"return\", reject(response));\n\n            case 4:\n              message = {};\n              message.userAddress = signer.toLowerCase();\n              message.providerId = engine.providerId;\n              _context.next = 9;\n              return _getUserNonce(signer, _this);\n\n            case 9:\n              nonce = _context.sent;\n\n              if (!nonce) {\n                nonce = 0;\n              }\n\n              message.nonce = nonce;\n              dataToSign = {\n                types: {\n                  EIP712Domain: loginDomainType,\n                  LoginMessage: loginMessageType\n                },\n                domain: loginDomainData,\n                primaryType: \"LoginMessage\",\n                message: message\n              };\n              resolve(dataToSign);\n              _context.next = 19;\n              break;\n\n            case 16:\n              _context.prev = 16;\n              _context.t0 = _context[\"catch\"](0);\n              reject(_context.t0);\n\n            case 19:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 16]]);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n};\n/**\n * This method returns an EIP712 formatted data ready to be signed\n * that will be used while sending the transaction using web3.eth.sendSignedTransaction\n * Returned data structure types\n * RelayerPaymentType [\n *   { name: \"token\", type: \"address\"},\n *   { name: \"amount\", type: \"uint256\"}\n * ]\n\n * MetaTransactionType = [\n *\t{ name: \"from\", type: \"address\"},\n *\t{ name: \"to\", type: \"address\"},\n *\t{ name: \"data\", type: \"bytes\"},\n *\t{ name: \"batchId\", type: \"uint256\"},\n *\t{ name: \"nonce\", type: \"uint256\"},\n *\t{ name: \"expiry\", type: \"uint256\"},\n *\t{ name: \"txGas\", type: \"uint256\"},\n *\t{ name: \"baseGas\", type: \"uint256\"},\n *\t{ name: \"value\", type: \"uint256\"},\n *  { name: \"metaInfo\", type: \"MetaInfo\"},\n *  { name: \"relayerPayment\", type: \"RelayerPayment\"}\n * ]\n */\n\n\nBiconomy.prototype.getUserMessageToSign = function (rawTransaction, cb) {\n  var engine = this;\n  return new Promise( /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(resolve, reject) {\n      var decodedTx, methodInfo, error, methodName, api, params, paramArray, i, account, _error, userContractWallet, _error2, metaInfo, relayerPayment, message, nonce, dataToSign, _error3;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!rawTransaction) {\n                _context2.next = 56;\n                break;\n              }\n\n              decodedTx = txDecoder.decodeTx(rawTransaction);\n\n              if (!(decodedTx.to && decodedTx.data && decodedTx.value)) {\n                _context2.next = 53;\n                break;\n              }\n\n              methodInfo = decodeMethod(decodedTx.to.toLowerCase(), decodedTx.data);\n\n              if (methodInfo) {\n                _context2.next = 8;\n                break;\n              }\n\n              error = formatMessage(RESPONSE_CODES.DASHBOARD_DATA_MISMATCH, \"Smart Contract address registered on dashboard is different than what is sent(\".concat(decodedTx.to, \") in current transaction\"));\n              if (cb) cb(error);\n              return _context2.abrupt(\"return\", reject(error));\n\n            case 8:\n              methodName = methodInfo.name;\n              api = engine.dappAPIMap[methodName];\n\n              if (!api) {\n                _logMessage(\"API not found for method \".concat(methodName));\n              }\n\n              _logMessage('API found');\n\n              params = methodInfo.params;\n              paramArray = [];\n\n              for (i = 0; i < params.length; i++) {\n                paramArray.push(_getParamValue(params[i]));\n              }\n\n              account = web3.eth.accounts.recoverTransaction(rawTransaction);\n\n              _logMessage(\"signer is \".concat(account));\n\n              if (account) {\n                _context2.next = 20;\n                break;\n              }\n\n              _error = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Not able to get user account from signed transaction\");\n              return _context2.abrupt(\"return\", end(_error));\n\n            case 20:\n              _context2.next = 22;\n              return _getUserContractWallet(engine, account);\n\n            case 22:\n              userContractWallet = _context2.sent;\n\n              _logMessage(\"User contract wallet \".concat(userContractWallet));\n\n              if (userContractWallet) {\n                _context2.next = 28;\n                break;\n              }\n\n              _error2 = formatMessage(RESPONSE_CODES.USER_CONTRACT_NOT_FOUND, \"User contract wallet not found\");\n              if (cb) cb(_error2);\n              return _context2.abrupt(\"return\", reject(_error2));\n\n            case 28:\n              metaInfo = {};\n              metaInfo.contractWallet = userContractWallet;\n              relayerPayment = {};\n              relayerPayment.token = config.DEFAULT_RELAYER_PAYMENT_TOKEN_ADDRESS;\n              relayerPayment.amount = config.DEFAULT_RELAYER_PAYMENT_AMOUNT;\n              message = {};\n              message.from = account;\n              message.to = decodedTx.to.toLowerCase();\n              message.data = decodedTx.data;\n              message.batchId = config.NONCE_BATCH_ID;\n              _context2.next = 40;\n              return _getUserContractNonce(account, engine);\n\n            case 40:\n              nonce = _context2.sent;\n              message.nonce = parseInt(nonce);\n              message.value = web3.utils.toHex(decodedTx.value);\n              message.txGas = decodedTx.gasLimit.toString() ? decodedTx.gasLimit.toString() : 0;\n              message.expiry = config.EXPIRY;\n              message.baseGas = config.BASE_GAS;\n              message.metaInfo = metaInfo;\n              message.relayerPayment = relayerPayment;\n              dataToSign = {\n                types: {\n                  EIP712Domain: domainType,\n                  MetaInfo: metaInfoType,\n                  RelayerPayment: relayerPaymentType,\n                  MetaTransaction: metaTransactionType\n                },\n                domain: domainData,\n                primaryType: \"MetaTransaction\",\n                message: message\n              };\n              if (cb) cb(null, dataToSign);\n              return _context2.abrupt(\"return\", resolve(dataToSign));\n\n            case 53:\n              _error3 = formatMessage(RESPONSE_CODES.BICONOMY_NOT_INITIALIZED, \"Decoders not initialized properly in mexa sdk. Make sure your have smart contracts registered on Mexa Dashboard\");\n              if (cb) cb(_error3);\n              return _context2.abrupt(\"return\", reject(_error3));\n\n            case 56:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x3, _x4) {\n      return _ref2.apply(this, arguments);\n    };\n  }());\n};\n/**\n * Method used to listen to events emitted from the SDK\n */\n\n\nBiconomy.prototype.onEvent = function (type, callback) {\n  if (type == this.READY || type == this.ERROR || type == this.LOGIN_CONFIRMATION) {\n    eventEmitter.on(type, callback);\n    return this;\n  } else {\n    throw formatMessage(RESPONSE_CODES.EVENT_NOT_SUPPORTED, \"\".concat(type, \" event is not supported.\"));\n  }\n};\n/**\n * Create a JSON RPC response from the given error and result parameter.\n **/\n\n\nfunction _createJsonRpcResponse(payload, error, result) {\n  var response = {};\n  response.id = payload.id;\n  response.jsonrpc = JSON_RPC_VERSION;\n\n  if (error) {\n    response.error = error;\n  } else if (result.error) {\n    response.error = result.error;\n  } else if (web3.utils.isHex(result)) {\n    response.result = result;\n  } else {\n    response = result;\n  }\n\n  return response;\n}\n\nfunction decodeMethod(to, data) {\n  if (to && data && decoderMap[to]) {\n    return decoderMap[to].decodeMethod(data);\n  }\n\n  return;\n}\n/**\n * Method used to handle transaction initiated using web3.eth.sendSignedTransaction method\n * It extracts rawTransaction from payload and decode it to get required information like from, to,\n * data, gasLimit to create the payload for biconomy meta transaction API.\n * In case of Native meta transaction, payload just contains rawTransaction\n * In case of contract based meta transaction, payload contains rawTransaction and signature wrapped\n * in a json object.\n *\n * @param {Object} engine Reference to this SDK instance\n * @param {Object} payload Payload data\n * @param {Function} end Callback function with error as first argument\n */\n\n\nfunction sendSignedTransaction(_x5, _x6, _x7) {\n  return _sendSignedTransaction.apply(this, arguments);\n}\n/**\n * Method to withdraw ether from use contract wallets.\n * It takes the receiverAddress and withdraw amount in wei.\n * An optional callback parameter can also be given that has first parameter as error and\n * second parameter as result containing withdraw transaction hash.\n *\n * Returns a promise that resolves to result object containing withdraw transaction hash.\n */\n\n\nfunction _sendSignedTransaction() {\n  _sendSignedTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(engine, payload, end) {\n    var data, rawTransaction, signature, decodedTx, methodInfo, error, methodName, api, _error5, params, paramArray, i, account, _error6, _data, _error7, relayerPayment, _data2, _error8, _error9, _error10, _error11;\n\n    return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            if (!(payload && payload.params[0])) {\n              _context11.next = 61;\n              break;\n            }\n\n            data = payload.params[0];\n\n            if (typeof data == \"string\") {\n              // Here user send the rawTransaction in the payload directly. Probably the case of native meta transaction\n              rawTransaction = data;\n            } else if (typeof data == \"object\") {\n              // Here user wrapped raw Transaction in json object along with signature\n              signature = data.signature;\n              rawTransaction = data.rawTransaction;\n            }\n\n            if (!rawTransaction) {\n              _context11.next = 56;\n              break;\n            }\n\n            decodedTx = txDecoder.decodeTx(rawTransaction);\n\n            if (!(decodedTx.to && decodedTx.data && decodedTx.value)) {\n              _context11.next = 51;\n              break;\n            }\n\n            methodInfo = decodeMethod(decodedTx.to.toLowerCase(), decodedTx.data);\n\n            if (methodInfo) {\n              _context11.next = 10;\n              break;\n            }\n\n            error = formatMessage(RESPONSE_CODES.DASHBOARD_DATA_MISMATCH, \"Smart Contract address registered on dashboard is different than what is sent(\".concat(decodedTx.to, \") in current transaction\"));\n            return _context11.abrupt(\"return\", end(error));\n\n          case 10:\n            methodName = methodInfo.name;\n            api = engine.dappAPIMap[methodName];\n\n            if (api) {\n              _context11.next = 22;\n              break;\n            }\n\n            _logMessage(\"API not found for method \".concat(methodName));\n\n            _logMessage(\"Strict mode \".concat(engine.strictMode));\n\n            if (!engine.strictMode) {\n              _context11.next = 20;\n              break;\n            }\n\n            _error5 = formatMessage(RESPONSE_CODES.API_NOT_FOUND, \"Biconomy strict mode is on. No registered API found for method \".concat(methodName, \". Please register API from developer dashboard.\"));\n            return _context11.abrupt(\"return\", end(_error5, null));\n\n          case 20:\n            _logMessage(\"Falling back to default provider as strict mode is false in biconomy\");\n\n            return _context11.abrupt(\"return\", engine.providerSend(rawTransaction, end));\n\n          case 22:\n            _logMessage('API found');\n\n            params = methodInfo.params;\n            paramArray = [];\n\n            for (i = 0; i < params.length; i++) {\n              paramArray.push(_getParamValue(params[i]));\n            }\n\n            account = web3.eth.accounts.recoverTransaction(rawTransaction);\n\n            _logMessage(\"signer is \".concat(account));\n\n            if (account) {\n              _context11.next = 31;\n              break;\n            }\n\n            _error6 = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Not able to get user account from signed transaction\");\n            return _context11.abrupt(\"return\", end(_error6));\n\n          case 31:\n            if (!(api.url == NATIVE_META_TX_URL)) {\n              _context11.next = 41;\n              break;\n            }\n\n            _data = {};\n            _data.userAddress = account;\n            _data.apiId = api.id;\n            _data.params = paramArray;\n            _data.gasLimit = decodedTx.gasLimit.toString();\n            _data.gasPrice = decodedTx.gasPrice.toString();\n\n            _sendTransaction(engine, account, api, _data, end);\n\n            _context11.next = 49;\n            break;\n\n          case 41:\n            if (engine.isLogin) {\n              _context11.next = 48;\n              break;\n            }\n\n            _error7 = {};\n            _error7.message = 'User not logged in to biconomy';\n            _error7.code = RESPONSE_CODES.USER_NOT_LOGGED_IN;\n            return _context11.abrupt(\"return\", end(_error7));\n\n          case 48:\n            if (signature) {\n              relayerPayment = {};\n              relayerPayment.token = config.DEFAULT_RELAYER_PAYMENT_TOKEN_ADDRESS;\n              relayerPayment.amount = config.DEFAULT_RELAYER_PAYMENT_AMOUNT;\n              _data2 = {};\n              _data2.rawTx = rawTransaction;\n              _data2.signature = signature;\n              _data2.to = decodedTx.to.toLowerCase();\n              _data2.from = account;\n              _data2.apiId = api.id;\n              _data2.data = decodedTx.data;\n              _data2.value = web3.utils.toHex(decodedTx.value);\n              _data2.gasLimit = decodedTx.gasLimit.toString();\n              _data2.gasPrice = decodedTx.gasPrice.toString();\n              _data2.nonceBatchId = config.NONCE_BATCH_ID;\n              _data2.expiry = config.EXPIRY;\n              _data2.baseGas = config.BASE_GAS;\n              _data2.relayerPayment = {\n                token: relayerPayment.token,\n                amount: relayerPayment.amount\n              };\n\n              _sendTransaction(engine, account, api, _data2, end);\n            } else {\n              _error8 = formatMessage(RESPONSE_CODES.INVALID_PAYLOAD, \"Invalid payload data \".concat(JSON.stringify(payload.params[0]), \". message and signature are required in param object\"));\n              eventEmitter.emit(EVENTS.BICONOMY_ERROR, _error8);\n              end(_error8);\n            }\n\n          case 49:\n            _context11.next = 54;\n            break;\n\n          case 51:\n            _error9 = formatMessage(RESPONSE_CODES.BICONOMY_NOT_INITIALIZED, \"Decoders not initialized properly in mexa sdk. Make sure your have smart contracts registered on Mexa Dashboard\");\n            eventEmitter.emit(EVENTS.BICONOMY_ERROR, _error9);\n            end(_error9);\n\n          case 54:\n            _context11.next = 59;\n            break;\n\n          case 56:\n            _error10 = formatMessage(RESPONSE_CODES.INVALID_PAYLOAD, \"Invalid payload data \".concat(JSON.stringify(payload.params[0]), \".rawTransaction is required in param object\"));\n            eventEmitter.emit(EVENTS.BICONOMY_ERROR, _error10);\n            end(_error10);\n\n          case 59:\n            _context11.next = 64;\n            break;\n\n          case 61:\n            _error11 = formatMessage(RESPONSE_CODES.INVALID_PAYLOAD, \"Invalid payload data \".concat(JSON.stringify(payload.params[0]), \". Non empty Array expected in params key\"));\n            eventEmitter.emit(EVENTS.BICONOMY_ERROR, _error11);\n            end(_error11);\n\n          case 64:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, _callee11);\n  }));\n  return _sendSignedTransaction.apply(this, arguments);\n}\n\nBiconomy.prototype.withdrawFunds = function (receiverAddress, withdrawAmount, cb) {\n  var _this2 = this;\n\n  var engine = this;\n  return new Promise( /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(resolve, reject) {\n      var account, nonce, userContractWallet, error, metaInfo, relayerPayment, message, dataToSign;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return _getUserAccount(_this2);\n\n            case 2:\n              account = _context3.sent;\n              _context3.next = 5;\n              return _getUserContractNonce(account, _this2);\n\n            case 5:\n              nonce = _context3.sent;\n              _context3.next = 8;\n              return _getUserContractWallet(engine, account);\n\n            case 8:\n              userContractWallet = _context3.sent;\n\n              if (userContractWallet) {\n                _context3.next = 14;\n                break;\n              }\n\n              error = formatMessage(RESPONSE_CODES.USER_CONTRACT_NOT_FOUND, \"User contract wallet not found\");\n              eventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n              if (cb) cb(error);\n              return _context3.abrupt(\"return\", reject(error));\n\n            case 14:\n              metaInfo = {};\n              metaInfo.contractWallet = userContractWallet;\n              relayerPayment = {};\n              relayerPayment.token = config.DEFAULT_RELAYER_PAYMENT_TOKEN_ADDRESS;\n              relayerPayment.amount = config.DEFAULT_RELAYER_PAYMENT_AMOUNT;\n              message = {};\n              message.from = account;\n              message.to = receiverAddress;\n              message.data = \"0x0\";\n              message.batchId = config.NONCE_BATCH_ID;\n              message.nonce = parseInt(nonce);\n              message.value = web3.utils.toHex(withdrawAmount || 0);\n              message.txGas = 0;\n              message.expiry = config.EXPIRY;\n              message.baseGas = config.BASE_GAS;\n              message.metaInfo = metaInfo;\n              message.relayerPayment = relayerPayment;\n              dataToSign = JSON.stringify({\n                types: {\n                  EIP712Domain: domainType,\n                  MetaInfo: metaInfoType,\n                  RelayerPayment: relayerPaymentType,\n                  MetaTransaction: metaTransactionType\n                },\n                domain: domainData,\n                primaryType: \"MetaTransaction\",\n                message: message\n              });\n\n              try {\n                web3.currentProvider.send({\n                  jsonrpc: JSON_RPC_VERSION,\n                  id: DEFAULT_PAYLOAD_ID,\n                  method: config.signTypedV3Method,\n                  params: [account, dataToSign]\n                }, function (error, response) {\n                  _logMessage(\"User signature for payload id \".concat(DEFAULT_PAYLOAD_ID, \" is \").concat(response.result));\n\n                  if (error) {\n                    if (cb) {\n                      cb(error);\n                    }\n\n                    reject(error);\n                  } else if (response && response.error) {\n                    if (cb) cb(response.error);\n                    reject(response.error);\n                  } else if (response && response.result) {\n                    var data = {};\n                    data.signature = response.result;\n                    data.to = receiverAddress;\n                    data.value = web3.utils.toHex(withdrawAmount) || 0;\n                    data.from = account;\n                    data.data = \"0x0\";\n                    data.expiry = config.EXPIRY;\n                    data.baseGas = config.BASE_GAS;\n                    data.gasLimit = 0;\n                    data.nonceBatchId = config.NONCE_BATCH_ID;\n                    data.relayerPayment = relayerPayment;\n                    axios.defaults.headers.common[\"x-api-key\"] = engine.apiKey;\n                    axios.post(\"\".concat(baseURL).concat(withdrawFundsUrl), data).then(function (response) {\n                      if (response && response.data) {\n                        if (cb) cb(null, response.data);\n                        var result = formatMessage(RESPONSE_CODES.SUCCESS_RESPONSE, response.data.log);\n                        result.txHash = response.data.txHash;\n                        resolve(result);\n                      } else {\n                        var _error4 = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Unable to get response for api \".concat(withdrawFundsUrl));\n\n                        if (cb) cb(_error4);\n                        reject(_error4);\n                      }\n                    }).catch(function (error) {\n                      if (cb) cb(formatMessage(error.flag, error.log));\n                      reject(formatMessage(error.flag, error.log));\n                    });\n                  }\n                });\n              } catch (error) {\n                if (cb) cb(error);\n                reject(error);\n              }\n\n            case 33:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function (_x8, _x9) {\n      return _ref3.apply(this, arguments);\n    };\n  }());\n};\n/**\n * Function decodes the parameter in payload and gets the user signature using eth_signTypedData_v3\n * method and send the request to biconomy for processing and call the callback method 'end'\n * with transaction hash.\n *\n * This is an internal function that is called while intercepting eth_sendTransaction RPC method call.\n **/\n\n\nfunction handleSendTransaction(_x10, _x11, _x12) {\n  return _handleSendTransaction.apply(this, arguments);\n}\n/**\n * It fetches the user nonce used during login.\n *\n * @param {string} address User address whole nonce is requested\n * @param {object} engine Reference to Mexa object.\n */\n\n\nfunction _handleSendTransaction() {\n  _handleSendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(engine, payload, end) {\n    var methodInfo, methodName, api, gasPrice, gasLimit, error, params, paramArray, i, account, data, nonce, _error12, userContractWallet, _error13, contractABI, contract, metaInfo, relayerPayment, message, dataToSign, _error14, _error15, _error16;\n\n    return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n      while (1) {\n        switch (_context12.prev = _context12.next) {\n          case 0:\n            _logMessage('Handle transaction with payload');\n\n            _logMessage(payload);\n\n            if (!(payload.params && payload.params[0] && payload.params[0].to)) {\n              _context12.next = 95;\n              break;\n            }\n\n            if (!decoderMap[payload.params[0].to.toLowerCase()]) {\n              _context12.next = 90;\n              break;\n            }\n\n            methodInfo = decodeMethod(payload.params[0].to.toLowerCase(), payload.params[0].data);\n            methodName = methodInfo.name;\n            api = engine.dappAPIMap[methodName];\n            gasPrice = payload.params[0].gasPrice;\n            gasLimit = payload.params[0].gas;\n\n            _logMessage(api);\n\n            if (api) {\n              _context12.next = 22;\n              break;\n            }\n\n            _logMessage(\"API not found for method \".concat(methodName));\n\n            _logMessage(\"Strict mode \".concat(engine.strictMode));\n\n            if (!engine.strictMode) {\n              _context12.next = 20;\n              break;\n            }\n\n            error = {};\n            error.code = RESPONSE_CODES.API_NOT_FOUND;\n            error.message = \"Biconomy strict mode is on. No registered API found for method \".concat(methodName, \". Please register API from developer dashboard.\");\n            return _context12.abrupt(\"return\", end(error, null));\n\n          case 20:\n            _logMessage(\"Falling back to default provider as strict mode is false in biconomy\");\n\n            return _context12.abrupt(\"return\", engine.providerSend(payload, end));\n\n          case 22:\n            console.info('API found');\n            params = methodInfo.params;\n            paramArray = [];\n\n            for (i = 0; i < params.length; i++) {\n              paramArray.push(_getParamValue(params[i]));\n            }\n\n            console.info(\"Getting user account\");\n            _context12.next = 29;\n            return _getUserAccount(engine, payload);\n\n          case 29:\n            account = _context12.sent;\n\n            if (account) {\n              _context12.next = 32;\n              break;\n            }\n\n            return _context12.abrupt(\"return\", end(\"Not able to get user account\"));\n\n          case 32:\n            console.info(\"User account fetched\");\n\n            if (!(api.url == NATIVE_META_TX_URL)) {\n              _context12.next = 43;\n              break;\n            }\n\n            data = {};\n            data.userAddress = account;\n            data.apiId = api.id;\n            data.params = paramArray;\n            data.gasPrice = gasPrice;\n            data.gasLimit = gasLimit;\n\n            _sendTransaction(engine, account, api, data, end);\n\n            _context12.next = 88;\n            break;\n\n          case 43:\n            if (!engine.isLogin) {\n              _context12.next = 84;\n              break;\n            }\n\n            _context12.next = 46;\n            return _getUserContractNonce(account, engine);\n\n          case 46:\n            nonce = _context12.sent;\n\n            if (!nonce) {\n              _error12 = formatMessage(RESPONSE_CODES.USER_ACCOUNT_NOT_FOUND, \"User is not a registered biconomy user\");\n              eventEmitter.emit(EVENTS.BICONOMY_ERROR, _error12);\n              end(_error12);\n            }\n\n            _context12.next = 50;\n            return _getUserContractWallet(engine, account);\n\n          case 50:\n            userContractWallet = _context12.sent;\n\n            if (userContractWallet) {\n              _context12.next = 55;\n              break;\n            }\n\n            _error13 = formatMessage(RESPONSE_CODES.USER_CONTRACT_NOT_FOUND, \"User contract wallet not found\");\n            eventEmitter.emit(EVENTS.BICONOMY_ERROR, _error13);\n            return _context12.abrupt(\"return\", end(_error13));\n\n          case 55:\n            if (!(!gasLimit || parseInt(gasLimit) == 0)) {\n              _context12.next = 62;\n              break;\n            }\n\n            contractABI = smartContractMap[payload.params[0].to.toLowerCase()];\n\n            if (!contractABI) {\n              _context12.next = 62;\n              break;\n            }\n\n            contract = new web3.eth.Contract(JSON.parse(contractABI), payload.params[0].to.toLowerCase());\n            _context12.next = 61;\n            return contract.methods[methodName].apply(null, paramArray).estimateGas({\n              from: userContractWallet\n            });\n\n          case 61:\n            gasLimit = _context12.sent;\n\n          case 62:\n            metaInfo = {};\n            metaInfo.contractWallet = userContractWallet;\n            relayerPayment = {};\n            relayerPayment.token = config.DEFAULT_RELAYER_PAYMENT_TOKEN_ADDRESS;\n            relayerPayment.amount = config.DEFAULT_RELAYER_PAYMENT_AMOUNT;\n            message = {};\n            message.from = account;\n            message.to = payload.params[0].to.toLowerCase();\n            message.data = payload.params[0].data;\n            message.batchId = config.NONCE_BATCH_ID;\n            message.nonce = parseInt(nonce);\n            message.value = web3.utils.toHex(payload.params[0].value || 0);\n            message.txGas = gasLimit ? gasLimit : 0;\n            message.expiry = config.EXPIRY;\n            message.baseGas = config.BASE_GAS;\n            message.metaInfo = metaInfo;\n            message.relayerPayment = relayerPayment;\n            dataToSign = JSON.stringify({\n              types: {\n                EIP712Domain: domainType,\n                MetaInfo: metaInfoType,\n                RelayerPayment: relayerPaymentType,\n                MetaTransaction: metaTransactionType\n              },\n              domain: domainData,\n              primaryType: \"MetaTransaction\",\n              message: message\n            });\n            console.debug(dataToSign);\n            engine.send({\n              jsonrpc: JSON_RPC_VERSION,\n              id: payload.id,\n              method: config.signTypedV3Method,\n              params: [account, dataToSign]\n            }, function (error, response) {\n              console.info(\"User signature for payload id \".concat(payload.id, \" is \").concat(response.result));\n\n              if (error) {\n                end(error);\n              } else if (response && response.error) {\n                end(response.error);\n              } else if (response && response.result) {\n                var _data3 = {};\n                _data3.signature = response.result;\n                _data3.from = account;\n                _data3.to = payload.params[0].to.toLowerCase();\n                _data3.apiId = api.id;\n                _data3.dappId = engine.dappId;\n                _data3.data = payload.params[0].data;\n                _data3.nonceBatchId = config.NONCE_BATCH_ID;\n                _data3.expiry = config.EXPIRY;\n                _data3.baseGas = config.BASE_GAS;\n                _data3.userContract = userContractWallet;\n                _data3.value = web3.utils.toHex(payload.params[0].value || 0);\n                _data3.gasPrice = gasPrice;\n                _data3.gasLimit = gasLimit ? gasLimit : 0;\n                _data3.relayerPayment = {\n                  token: relayerPayment.token,\n                  amount: relayerPayment.amount\n                };\n\n                _sendTransaction(engine, account, api, _data3, end);\n              } else {\n                end();\n              }\n            });\n            _context12.next = 88;\n            break;\n\n          case 84:\n            _error14 = {};\n            _error14.message = 'User not logged in to biconomy';\n            _error14.code = RESPONSE_CODES.USER_NOT_LOGGED_IN;\n            return _context12.abrupt(\"return\", end(_error14));\n\n          case 88:\n            _context12.next = 93;\n            break;\n\n          case 90:\n            _error15 = formatMessage(RESPONSE_CODES.BICONOMY_NOT_INITIALIZED, \"Decoders not initialized properly in mexa sdk. Make sure your have smart contracts registered on Mexa Dashboard\");\n            eventEmitter.emit(EVENTS.BICONOMY_ERROR, _error15);\n            end(_error15);\n\n          case 93:\n            _context12.next = 98;\n            break;\n\n          case 95:\n            _error16 = formatMessage(RESPONSE_CODES.INVALID_PAYLOAD, \"Invalid payload data \".concat(JSON.stringify(payload), \". Expecting params key to be an array with first element having a 'to' property\"));\n            eventEmitter.emit(EVENTS.BICONOMY_ERROR, _error16);\n            end(_error16);\n\n          case 98:\n          case \"end\":\n            return _context12.stop();\n        }\n      }\n    }, _callee12);\n  }));\n  return _handleSendTransaction.apply(this, arguments);\n}\n\nfunction _getUserNonce(_x13, _x14) {\n  return _getUserNonce2.apply(this, arguments);\n}\n/**\n * It query biconomy server for user contract nonce.\n *\n * @param {string} address user address whole nonce is requested\n * @param {object} engine Reference to mexa object\n */\n\n\nfunction _getUserNonce2() {\n  _getUserNonce2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(address, engine) {\n    var getNonceAPI, response;\n    return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            _context13.prev = 0;\n            getNonceAPI = \"\".concat(baseURL, \"/api/\").concat(config.version, \"/dapp-user/getNonce?signer=\").concat(address);\n            axios.defaults.headers.common[\"x-api-key\"] = engine.apiKey;\n            _context13.next = 5;\n            return axios.get(getNonceAPI);\n\n          case 5:\n            response = _context13.sent;\n\n            if (!(response && response.status == 200 && response.data)) {\n              _context13.next = 8;\n              break;\n            }\n\n            return _context13.abrupt(\"return\", response.data.nonce);\n\n          case 8:\n            return _context13.abrupt(\"return\");\n\n          case 11:\n            _context13.prev = 11;\n            _context13.t0 = _context13[\"catch\"](0);\n\n            if (!(_context13.t0.response.status == 404)) {\n              _context13.next = 15;\n              break;\n            }\n\n            return _context13.abrupt(\"return\", 0);\n\n          case 15:\n            return _context13.abrupt(\"return\");\n\n          case 16:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, _callee13, null, [[0, 11]]);\n  }));\n  return _getUserNonce2.apply(this, arguments);\n}\n\nfunction _getUserContractNonce(_x15, _x16) {\n  return _getUserContractNonce2.apply(this, arguments);\n} // On getting smart contract data get the API data also\n\n\nfunction _getUserContractNonce2() {\n  _getUserContractNonce2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(address, engine) {\n    var getNonceAPI, response;\n    return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n      while (1) {\n        switch (_context14.prev = _context14.next) {\n          case 0:\n            _context14.prev = 0;\n            getNonceAPI = \"\".concat(baseURL, \"/api/\").concat(config.version2, \"/dapp-user/getContractNonce?signer=\").concat(address);\n            axios.defaults.headers.common[\"x-api-key\"] = engine.apiKey;\n            _context14.next = 5;\n            return axios.get(getNonceAPI);\n\n          case 5:\n            response = _context14.sent;\n\n            if (!(response && response.status == 200 && response.data)) {\n              _context14.next = 8;\n              break;\n            }\n\n            return _context14.abrupt(\"return\", response.data.nonce);\n\n          case 8:\n            return _context14.abrupt(\"return\");\n\n          case 11:\n            _context14.prev = 11;\n            _context14.t0 = _context14[\"catch\"](0);\n\n            _logMessage(_context14.t0);\n\n            return _context14.abrupt(\"return\");\n\n          case 15:\n          case \"end\":\n            return _context14.stop();\n        }\n      }\n    }, _callee14, null, [[0, 11]]);\n  }));\n  return _getUserContractNonce2.apply(this, arguments);\n}\n\neventEmitter.on(EVENTS.SMART_CONTRACT_DATA_READY, function (dappId, engine) {\n  // Get DApp API information from Database\n  var getAPIInfoAPI = \"\".concat(baseURL, \"/api/\").concat(config.version, \"/meta-api?dappId=\").concat(dappId);\n  axios.get(getAPIInfoAPI).then(function (response) {\n    if (response && response.data && response.data.listApis) {\n      var apiList = response.data.listApis;\n\n      for (var i = 0; i < apiList.length; i++) {\n        engine.dappAPIMap[apiList[i].method] = apiList[i];\n      }\n\n      eventEmitter.emit(EVENTS.DAPP_API_DATA_READY, engine);\n    }\n  }).catch(function (error) {\n    console.error(error);\n  });\n});\neventEmitter.on(EVENTS.DAPP_API_DATA_READY, function (engine) {\n  engine.status = STATUS.BICONOMY_READY;\n  eventEmitter.emit(STATUS.BICONOMY_READY);\n});\n/**\n * Get user account from current provider using eth_accounts method.\n **/\n\nfunction _getUserAccount(engine, payload, cb) {\n  if (engine) {\n    var id = DEFAULT_PAYLOAD_ID;\n\n    if (payload) {\n      id = payload.id;\n    }\n\n    if (cb) {\n      web3.currentProvider.send({\n        jsonrpc: JSON_RPC_VERSION,\n        id: id,\n        method: 'eth_accounts',\n        params: []\n      }, function (error, response) {\n        if (response && response.result && response.result.length == 0 && web3.eth.defaultAccount && web3.eth.defaultAccount != \"\") {\n          response.result.push(web3.eth.defaultAccount);\n          cb(error, response);\n        } else {\n          cb(error, response);\n        }\n      });\n    } else {\n      return new Promise(function (resolve, reject) {\n        web3.currentProvider.send({\n          jsonrpc: JSON_RPC_VERSION,\n          id: id,\n          method: 'eth_accounts',\n          params: []\n        }, function (error, res) {\n          if (error) {\n            reject(error);\n          } else if (!res.result) {\n            reject(\"Invalid response \".concat(res));\n          } else if (res.result && res.result.length == 0 && web3.eth.defaultAccount && web3.eth.defaultAccount != \"\") {\n            resolve(web3.eth.defaultAccount);\n          } else {\n            resolve(res.result[0]);\n          }\n        });\n      });\n    }\n  }\n}\n/**\n * Validate parameters passed to biconomy object. Dapp id and api key are mandatory.\n **/\n\n\nfunction _validate(options) {\n  if (!options) {\n    throw new Error(\"Options object needs to be passed to Biconomy Object with dappId and apiKey mandatory keys\");\n  }\n\n  if (!options.dappId || !options.apiKey) {\n    throw new Error(\"dappId and apiKey are required in options object when creating Biconomy object\");\n  }\n}\n/**\n * Get paramter value from param object based on its type.\n **/\n\n\nfunction _getParamValue(paramObj) {\n  var value;\n\n  if (paramObj) {\n    var type = paramObj.type;\n\n    switch (type) {\n      case (type.match(/^uint/) || type.match(/^int/) || {}).input:\n        value = scientificToDecimal(parseInt(paramObj.value));\n        value = web3.utils.toHex(value);\n        break;\n\n      case 'string':\n        if (typeof paramObj.value === \"object\") {\n          value = paramObj.value.toString();\n        } else {\n          value = paramObj.value;\n        }\n\n        break;\n\n      default:\n        value = paramObj.value;\n        break;\n    }\n  }\n\n  return value;\n}\n/**\n * Method to send the transaction to biconomy server and call the callback method\n * to pass the result of meta transaction to web3 function call.\n * @param engine Object representing biconomy provider engine\n * @param account User selected account on current wallet\n * @param api API object got from biconomy server\n * @param data Data to be sent to biconomy server having transaction data\n * @param cb Callback method to be called to pass result or send error\n **/\n\n\nfunction _sendTransaction(engine, account, api, data, cb) {\n  if (engine && account && api && data) {\n    var _url = api.url;\n    axios.post(\"\".concat(baseURL).concat(_url), data).then(function (response) {\n      if (response && response.data) {\n        var result = response.data;\n\n        _logMessage(result);\n\n        if (result.flag && result.flag != BICONOMY_RESPONSE_CODES.ACTION_COMPLETE && result.flag != BICONOMY_RESPONSE_CODES.SUCCESS) {\n          var error = {};\n          error.code = result.flag;\n\n          if (result.flag == BICONOMY_RESPONSE_CODES.USER_CONTRACT_NOT_FOUND) {\n            error.code = RESPONSE_CODES.USER_CONTRACT_NOT_FOUND;\n          }\n\n          error.message = result.log;\n          if (cb) cb(error);\n        } else {\n          if (cb) cb(null, result.txHash);\n        }\n      } else {\n        _logMessage(response);\n\n        if (cb) cb(formatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Invalid response from api \".concat(_url)));\n      }\n    }).catch(function (error) {\n      _logMessage(error);\n\n      if (cb) cb(error);\n    });\n  } else {\n    _logMessage(\"Invalid arguments, provider: \".concat(engine, \" account: \").concat(account, \" api: \").concat(api, \" data: \").concat(data));\n\n    if (cb) cb(\"Invalid arguments, provider: \".concat(engine, \" account: \").concat(account, \" api: \").concat(api, \" data: \").concat(data), null);\n  }\n}\n/**\n * Function to initialize the biconomy object with DApp information.\n * It fetches the dapp's smart contract from biconomy database and initialize the decoders for each smart\n * contract which will be used to decode information during function calls.\n * @param dappId Id for dapp whose information is to be fetched\n * @param apiKey API key used to authenticate the request at biconomy server\n * @param _this object representing biconomy provider\n **/\n\n\nfunction _init(_x17, _x18, _x19) {\n  return _init2.apply(this, arguments);\n}\n/**\n * Method to get user contract wallet from biconomy server.\n **/\n\n\nfunction _init2() {\n  _init2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(dappId, apiKey, engine) {\n    var getDappAPI;\n    return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n      while (1) {\n        switch (_context15.prev = _context15.next) {\n          case 0:\n            try {\n              // Check current network id and dapp network id registered on dashboard\n              getDappAPI = \"\".concat(baseURL, \"/api/\").concat(config.version, \"/dapp?dappId=\").concat(dappId);\n              axios.defaults.headers.common[\"x-api-key\"] = apiKey;\n              axios.get(getDappAPI).then(function (response) {\n                var dappResponse = response.data;\n\n                if (dappResponse && dappResponse.dapp) {\n                  var dappNetworkId = dappResponse.dapp.networkId;\n\n                  _logMessage(\"Network id corresponding to dapp id \".concat(dappId, \" is \").concat(dappNetworkId));\n\n                  web3.currentProvider.send({\n                    jsonrpc: JSON_RPC_VERSION,\n                    id: '102',\n                    method: 'net_version',\n                    params: []\n                  }, function (error, networkResponse) {\n                    if (error || networkResponse && networkResponse.error) {\n                      return eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.NETWORK_ID_NOT_FOUND, \"Could not get network version\"), error || networkResponse.error);\n                    } else {\n                      var providerNetworkId = networkResponse.result;\n\n                      _logMessage(\"Current provider network id: \".concat(providerNetworkId));\n\n                      if (providerNetworkId != dappNetworkId) {\n                        return eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.NETWORK_ID_MISMATCH, \"Current networkId \".concat(providerNetworkId, \" is different from dapp network id registered on mexa dashboard \").concat(dappNetworkId)));\n                      } else {\n                        domainData.chainId = providerNetworkId;\n                        axios.get(\"\".concat(baseURL, \"/api/\").concat(config.version2, \"/meta-tx/systemInfo?networkId=\").concat(providerNetworkId)).then(function (signatureTypesResult) {\n                          if (signatureTypesResult && signatureTypesResult.data) {\n                            var systemInfo = signatureTypesResult.data;\n                            domainType = systemInfo.domainType;\n                            metaInfoType = systemInfo.metaInfoType;\n                            relayerPaymentType = systemInfo.relayerPaymentType;\n                            metaTransactionType = systemInfo.metaTransactionType;\n                            loginDomainType = systemInfo.loginDomainType;\n                            loginMessageType = systemInfo.loginMessageType;\n                            loginDomainData = systemInfo.loginDomainData;\n\n                            if (systemInfo.relayHubAddress) {\n                              domainData.verifyingContract = systemInfo.relayHubAddress;\n                            }\n                          } else {\n                            return eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.INVALID_DATA, \"Could not get signature types from server. Contact Biconomy Team\"));\n                          } // Get dapps smart contract data from biconomy servers\n\n\n                          var getDAppInfoAPI = \"\".concat(baseURL, \"/api/\").concat(config.version, \"/smart-contract?dappId=\").concat(dappId);\n                          axios.get(getDAppInfoAPI).then(function (response) {\n                            var result = response.data;\n\n                            if (!result && result.flag != 143) {\n                              return eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.SMART_CONTRACT_NOT_FOUND, \"Error getting smart contract for dappId \".concat(dappId)));\n                            }\n\n                            var smartContractList = result.smartContracts;\n\n                            if (smartContractList && smartContractList.length > 0) {\n                              smartContractList.forEach(function (contract) {\n                                var abiDecoder = require('abi-decoder');\n\n                                abiDecoder.addABI(JSON.parse(contract.abi));\n                                decoderMap[contract.address.toLowerCase()] = abiDecoder;\n                                smartContractMap[contract.address.toLowerCase()] = contract.abi;\n                              });\n                              var userLocalAccount = getFromStorage(USER_ACCOUNT);\n                              var userLocalContract = getFromStorage(USER_CONTRACT);\n\n                              if (userLocalContract && userLocalAccount) {\n                                _getUserAccount(engine, undefined, function (error, response) {\n                                  if (error || !response || response.error) {\n                                    return eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.USER_ACCOUNT_NOT_FOUND, \"Could not get user account\"));\n                                  }\n\n                                  var account = response.result[0];\n\n                                  _getUserContractWallet(engine, account, function (error, userContract) {\n                                    if (userContract && account && account.toUpperCase() == userLocalAccount.toUpperCase() && userContract.toUpperCase() == userLocalContract.toUpperCase()) {\n                                      engine.isLogin = true;\n\n                                      _logMessage('Biconomy user login set to true');\n                                    }\n\n                                    eventEmitter.emit(EVENTS.SMART_CONTRACT_DATA_READY, dappId, engine);\n                                  });\n                                });\n                              } else {\n                                eventEmitter.emit(EVENTS.SMART_CONTRACT_DATA_READY, dappId, engine);\n                              }\n                            } else {\n                              engine.status = STATUS.NO_DATA;\n                              eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.SMART_CONTRACT_NOT_FOUND, \"No smart contract registered for dappId \".concat(dappId, \" on Mexa Dashboard\")));\n                            }\n                          }).catch(function (error) {\n                            eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Error while initializing Biconomy\"), error);\n                          });\n                        });\n                      }\n                    }\n                  });\n                } else {\n                  if (dappResponse.log) {\n                    eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.ERROR_RESPONSE, dappResponse.log));\n                  } else {\n                    eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.DAPP_NOT_FOUND, \"No Dapp Registered with dapp id \".concat(dappId)));\n                  }\n                }\n              }).catch(function (error) {\n                eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Error while initializing Biconomy\"), error);\n              });\n            } catch (error) {\n              eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Error while initializing Biconomy\"), error);\n            }\n\n          case 1:\n          case \"end\":\n            return _context15.stop();\n        }\n      }\n    }, _callee15);\n  }));\n  return _init2.apply(this, arguments);\n}\n\nfunction _getUserContractWallet(_x20, _x21, _x22) {\n  return _getUserContractWallet2.apply(this, arguments);\n}\n/**\n * Function used to login user. This creates a smart contract wallet for new user and\n * just returns contract wallet address for existing user.\n *\n * This function should be used when you have access to user's private key.\n *\n * @param {string} signer User Externally Owned Account (EOA) address\n * @param {string} signature EIP712 formatted signature signed using signer address\n * @param {function} cb Optional callback method with error first parameter\n *\n * @returns A promise that resolves to response containg transaction hash for new user\n * and user contract wallet address for existing user.\n *\n * Refer to https://docs.biconomy.io for more details on how to use it.\n */\n\n\nfunction _getUserContractWallet2() {\n  _getUserContractWallet2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(engine, address, cb) {\n    var promise;\n    return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n      while (1) {\n        switch (_context16.prev = _context16.next) {\n          case 0:\n            promise = new Promise(function (resolve, reject) {\n              if (address) {\n                engine.sendAsync({\n                  jsonrpc: JSON_RPC_VERSION,\n                  id: '102',\n                  method: 'net_version',\n                  params: []\n                }, function (error, response) {\n                  if (error || response && response.error) {\n                    console.error(error || response.error);\n                    eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.NETWORK_ID_NOT_FOUND, \"Could not get network version\"), error || networkResponse.error);\n                    reject(\"Could not get network version\");\n                  } else {\n                    var networkId = response.result;\n                    var data = {\n                      owner: address,\n                      networkId: networkId\n                    };\n                    axios.get(\"\".concat(baseURL).concat(getUserContractPath), {\n                      params: data\n                    }).then(function (response) {\n                      var data = response.data;\n                      console.debug(data);\n\n                      if (data.flag && data.flag == BICONOMY_RESPONSE_CODES.SUCCESS) {\n                        if (cb) {\n                          cb(null, data.userContract);\n                        }\n\n                        resolve(data.userContract);\n                      } else {\n                        if (cb) {\n                          cb(\"User contract not found\");\n                        }\n\n                        reject(\"User contract not found\");\n                      }\n                    }).catch(function (error) {\n                      _logMessage(error);\n\n                      var response = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Error while fetching user contract \".concat(JSON.stringify(error)));\n                      if (cb) cb(response);\n                      reject(response);\n                    });\n                  }\n                });\n              } else {\n                var response = formatMessage(RESPONSE_CODES.INVALID_DATA, \"Input address is not valid\");\n                if (cb) cb(response);\n                reject(response);\n              }\n            });\n            return _context16.abrupt(\"return\", promise);\n\n          case 2:\n          case \"end\":\n            return _context16.stop();\n        }\n      }\n    }, _callee16);\n  }));\n  return _getUserContractWallet2.apply(this, arguments);\n}\n\nBiconomy.prototype.accountLogin = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(signer, signature, cb) {\n    var engine;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            engine = this;\n            return _context5.abrupt(\"return\", new Promise( /*#__PURE__*/function () {\n              var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(resolve, reject) {\n                var data;\n                return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                  while (1) {\n                    switch (_context4.prev = _context4.next) {\n                      case 0:\n                        data = {};\n                        data.signature = signature;\n                        data.from = signer;\n                        data.providerId = engine.providerId;\n                        axios.post(\"\".concat(baseURL).concat(userLoginPath), data).then(function (response) {\n                          var data = response ? response.data : undefined;\n\n                          _logMessage(data);\n\n                          if (data) {\n                            var result = {};\n\n                            if (data.flag && data.flag == BICONOMY_RESPONSE_CODES.ACTION_COMPLETE) {\n                              result.code = RESPONSE_CODES.SUCCESS_RESPONSE;\n\n                              if (data.userContract) {\n                                result.message = \"User login successfull\";\n                                result.userContract = data.userContract;\n                                engine.isLogin = true;\n\n                                _setLocalData(signer, data.userContract);\n                              } else if (data.transactionHash) {\n                                result.message = \"User contract creation initiated\";\n                                result.transactionHash = data.transactionHash;\n                                loginInterval = setInterval(function () {\n                                  getLoginTransactionReceipt(engine, data.transactionHash, signer);\n                                }, 2000);\n                              }\n\n                              if (cb) cb(null, result);\n                              resolve(result);\n                            } else {\n                              result.code = RESPONSE_CODES.ERROR_RESPONSE;\n                              result.message = data.log;\n                              if (cb) cb(result, null);\n                              reject(result);\n                            }\n                          } else {\n                            var error = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Invalid response from api \".concat(url));\n                            if (cb) cb(error);\n                            reject(error);\n                          }\n                        }).catch(function (error) {\n                          _logMessage(error);\n\n                          cb(error, null);\n                          reject(error);\n                        });\n\n                      case 5:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }\n                }, _callee4);\n              }));\n\n              return function (_x26, _x27) {\n                return _ref5.apply(this, arguments);\n              };\n            }()));\n\n          case 2:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, this);\n  }));\n\n  return function (_x23, _x24, _x25) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nvar getLoginTransactionReceipt = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(engine, txHash, userAddress) {\n    var receipt;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return web3.eth.getTransactionReceipt(txHash);\n\n          case 2:\n            receipt = _context6.sent;\n\n            if (!receipt) {\n              _context6.next = 11;\n              break;\n            }\n\n            if (!receipt.status) {\n              _context6.next = 9;\n              break;\n            }\n\n            _context6.next = 7;\n            return _getUserContractWallet(engine, userAddress, function (error, userContract) {\n              if (!error && userContract) {\n                _setLocalData(userAddress, userContract);\n\n                engine.isLogin = true;\n                eventEmitter.emit(EVENTS.LOGIN_CONFIRMATION, \"User Contract wallet created Successfully\", userContract);\n              }\n            });\n\n          case 7:\n            _context6.next = 10;\n            break;\n\n          case 9:\n            if (!receipt.status) {\n              eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.USER_CONTRACT_CREATION_FAILED, \"User Contract wallet creation Failed\"));\n            }\n\n          case 10:\n            if (loginInterval) {\n              clearInterval(loginInterval);\n            }\n\n          case 11:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n\n  return function getLoginTransactionReceipt(_x28, _x29, _x30) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nBiconomy.prototype.isReady = function () {\n  return this.status === STATUS.BICONOMY_READY;\n};\n/**\n * Method used to login to biconomy. It takes user's public address as input\n * and if user contract wallet is not found for the user then it deploys\n * new user contract for the user. It user contract already exists it just\n * resolve to the contract wallet address.\n *\n * @returns Promise object that resolve to either transactionHash info or Contract wallet address\n **/\n\n\nBiconomy.prototype.login = /*#__PURE__*/function () {\n  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(signer, cb) {\n    var _this3 = this;\n\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            return _context8.abrupt(\"return\", new Promise( /*#__PURE__*/function () {\n              var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(resolve, reject) {\n                var response, engine, message, nonce, dataToSign;\n                return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n                  while (1) {\n                    switch (_context7.prev = _context7.next) {\n                      case 0:\n                        if (!(!signer || typeof signer != 'string')) {\n                          _context7.next = 5;\n                          break;\n                        }\n\n                        response = formatMessage(RESPONSE_CODES.INVALID_DATA, \"signer parameter is mandatory and should be of type 'string'\");\n                        if (cb) cb(response);\n                        reject(response);\n                        return _context7.abrupt(\"return\");\n\n                      case 5:\n                        engine = _this3;\n                        message = {};\n                        message.userAddress = signer.toLowerCase();\n                        message.providerId = engine.providerId;\n                        _context7.next = 11;\n                        return _getUserNonce(signer, _this3);\n\n                      case 11:\n                        nonce = _context7.sent;\n\n                        if (!nonce) {\n                          nonce = 0;\n                        }\n\n                        message.nonce = nonce;\n                        dataToSign = JSON.stringify({\n                          types: {\n                            EIP712Domain: loginDomainType,\n                            LoginMessage: loginMessageType\n                          },\n                          domain: loginDomainData,\n                          primaryType: \"LoginMessage\",\n                          message: message\n                        });\n                        console.debug(\"Biconomy engine status \".concat(engine.status));\n\n                        if (!(engine.status != STATUS.BICONOMY_READY)) {\n                          _context7.next = 18;\n                          break;\n                        }\n\n                        return _context7.abrupt(\"return\", cb(formatMessage(RESPONSE_CODES.BICONOMY_NOT_INITIALIZED, 'Biconomy SDK is not initialized properly')));\n\n                      case 18:\n                        web3.currentProvider.sendAsync({\n                          jsonrpc: JSON_RPC_VERSION,\n                          id: '101',\n                          method: config.signTypedV3Method,\n                          params: [signer, dataToSign]\n                        }, function (error, signature) {\n                          if (error) {\n                            var _response = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, error);\n\n                            if (cb) cb(_response);\n                            reject(_response);\n                          } else {\n                            var data = {};\n                            data.signature = signature.result;\n                            data.from = signer;\n                            data.providerId = engine.providerId;\n                            axios.post(\"\".concat(baseURL).concat(userLoginPath), data).then(function (response) {\n                              var data = response.data;\n                              console.debug(data);\n                              var result = {};\n\n                              if (data.flag && data.flag == BICONOMY_RESPONSE_CODES.ACTION_COMPLETE) {\n                                result.code = RESPONSE_CODES.SUCCESS_RESPONSE;\n\n                                if (data.userContract) {\n                                  result.message = \"User login successfull\";\n                                  result.userContract = data.userContract;\n                                  engine.isLogin = true;\n\n                                  _setLocalData(signer, data.userContract);\n                                } else if (data.transactionHash) {\n                                  result.message = \"User contract creation initiated\";\n                                  result.transactionHash = data.transactionHash;\n                                  loginInterval = setInterval(function () {\n                                    getLoginTransactionReceipt(engine, data.transactionHash, signer);\n                                  }, 2000);\n                                }\n\n                                if (cb) cb(null, result);\n                                resolve(result);\n                              } else {\n                                result.code = RESPONSE_CODES.ERROR_RESPONSE;\n                                result.message = data.log;\n                                if (cb) cb(result, null);\n                                reject(result);\n                              }\n                            }).catch(function (error) {\n                              console.debug(error);\n                              var response = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, error);\n                              if (cb) cb(response);\n                              reject(response);\n                            });\n                          }\n                        });\n\n                      case 19:\n                      case \"end\":\n                        return _context7.stop();\n                    }\n                  }\n                }, _callee7);\n              }));\n\n              return function (_x33, _x34) {\n                return _ref8.apply(this, arguments);\n              };\n            }()));\n\n          case 1:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n\n  return function (_x31, _x32) {\n    return _ref7.apply(this, arguments);\n  };\n}();\n/**\n * Function used to logout user from biconomy. It clears any internal user state and local storage.\n */\n\n\nBiconomy.prototype.logout = function () {\n  removeFromStorage(USER_ACCOUNT);\n  removeFromStorage(USER_CONTRACT);\n  this.isLogin = false;\n};\n/**\n * Function to return user contract wallet address.\n *\n * @param {string} userAddress User address for which contract wallet is requested\n * @returns A promise that resolves to user contact wallet if it exists else error response.\n */\n\n\nBiconomy.prototype.getUserContract = /*#__PURE__*/function () {\n  var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(userAddress) {\n    var response, userAddressFromStorage, userContract;\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            if (!this.isLogin) {\n              _context9.next = 11;\n              break;\n            }\n\n            userAddressFromStorage = getFromStorage(USER_ACCOUNT);\n\n            if (!(userAddressFromStorage && userAddress)) {\n              _context9.next = 9;\n              break;\n            }\n\n            if (userAddressFromStorage.toLowerCase() === userAddress.toLowerCase()) {\n              response = formatMessage(RESPONSE_CODES.SUCCESS_RESPONSE, \"User Contract Wallet address fetched successfully\");\n              response.userContract = getFromStorage(USER_CONTRACT);\n            }\n\n            if (response) {\n              _context9.next = 9;\n              break;\n            }\n\n            _context9.next = 7;\n            return _getUserContractWallet(this, userAddress);\n\n          case 7:\n            userContract = _context9.sent;\n\n            if (userContract) {\n              response = formatMessage(RESPONSE_CODES.SUCCESS_RESPONSE, \"User Contract Wallet address fetched successfully\");\n              response.userContract = userContract;\n            } else {\n              response = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Unable to fetch User Contract Wallet\");\n            }\n\n          case 9:\n            _context9.next = 12;\n            break;\n\n          case 11:\n            response = formatMessage(RESPONSE_CODES.USER_NOT_LOGGED_IN, \"Please login to biconomy first\");\n\n          case 12:\n            return _context9.abrupt(\"return\", response);\n\n          case 13:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9, this);\n  }));\n\n  return function (_x35) {\n    return _ref9.apply(this, arguments);\n  };\n}();\n\nBiconomy.prototype.getUserAccount = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n  return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n    while (1) {\n      switch (_context10.prev = _context10.next) {\n        case 0:\n          _context10.next = 2;\n          return _getUserAccount(this);\n\n        case 2:\n          return _context10.abrupt(\"return\", _context10.sent);\n\n        case 3:\n        case \"end\":\n          return _context10.stop();\n      }\n    }\n  }, _callee10, this);\n}));\n\nfunction formatMessage(code, message) {\n  return {\n    code: code,\n    message: message\n  };\n}\n/**\n * Setting data in localstorage to check later if user contract and user account\n * already exists and user has already logged in to biconomy once.\n **/\n\n\nfunction _setLocalData(signer, userContract) {\n  if (typeof localStorage != 'undefined') {\n    if (signer && userContract) {\n      localStorage.setItem(USER_ACCOUNT, signer);\n      localStorage.setItem(USER_CONTRACT, userContract);\n    }\n  } else {\n    this[USER_ACCOUNT] = signer;\n    this[USER_CONTRACT] = userContract;\n  }\n}\n\nfunction removeFromStorage(key) {\n  if (typeof localStorage != 'undefined') {\n    localStorage.removeItem(key);\n  } else {\n    this[key] = null;\n  }\n}\n\nfunction getFromStorage(key) {\n  if (typeof localStorage != 'undefined') {\n    return localStorage.getItem(key);\n  } else {\n    return this[key];\n  }\n}\n/**\n * Single method to be used for logging purpose.\n *\n * @param {string} message Message to be logged\n */\n\n\nfunction _logMessage(message) {\n  if (config && config.logsEnabled && console.log) {\n    console.log(message);\n  }\n}\n\nvar scientificToDecimal = function scientificToDecimal(num) {\n  var nsign = Math.sign(num); //remove the sign\n\n  num = Math.abs(num); //if the number is in scientific notation remove it\n\n  if (/\\d+\\.?\\d*e[\\+\\-]*\\d+/i.test(num)) {\n    var zero = '0',\n        parts = String(num).toLowerCase().split('e'),\n        //split into coeff and exponent\n    e = parts.pop(),\n        //store the exponential part\n    l = Math.abs(e),\n        //get the number of zeros\n    sign = e / l,\n        coeff_array = parts[0].split('.');\n\n    if (sign === -1) {\n      l = l - coeff_array[0].length;\n\n      if (l < 0) {\n        num = coeff_array[0].slice(0, l) + '.' + coeff_array[0].slice(l) + (coeff_array.length === 2 ? coeff_array[1] : '');\n      } else {\n        num = zero + '.' + new Array(l + 1).join(zero) + coeff_array.join('');\n      }\n    } else {\n      var dec = coeff_array[1];\n      if (dec) l = l - dec.length;\n\n      if (l < 0) {\n        num = coeff_array[0] + dec.slice(0, l) + '.' + dec.slice(l);\n      } else {\n        num = coeff_array.join('') + new Array(l + 1).join(zero);\n      }\n    }\n  }\n\n  return nsign < 0 ? '-' + num : num;\n};\n\nmodule.exports = Biconomy;","map":{"version":3,"sources":["/home/hayden/workplace/dapp-demo/node_modules/@biconomy/mexa/src/index.js"],"names":["axios","require","Promise","txDecoder","config","RESPONSE_CODES","EVENTS","BICONOMY_RESPONSE_CODES","STATUS","DEFAULT_PAYLOAD_ID","Web3","baseURL","userLoginPath","withdrawFundsUrl","getUserContractPath","JSON_RPC_VERSION","USER_ACCOUNT","USER_CONTRACT","NATIVE_META_TX_URL","nativeMetaTxUrl","decoderMap","smartContractMap","web3","events","eventEmitter","EventEmitter","loginInterval","domainType","metaInfoType","relayerPaymentType","metaTransactionType","domainData","name","eip712DomainName","version","eip712SigVersion","verifyingContract","eip712VerifyingContract","loginDomainType","loginMessageType","loginDomainData","Biconomy","provider","options","_validate","status","INIT","dappId","apiKey","isLogin","dappAPIMap","strictMode","providerId","readViaContract","READY","BICONOMY_READY","LOGIN_CONFIRMATION","ERROR","BICONOMY_ERROR","pendingLoginTransactions","debug","logsEnabled","_init","defaultAccount","eth","proto","Object","getPrototypeOf","keys","getOwnPropertyNames","i","length","key","providerSend","send","sendAsync","payload","cb","method","handleSendTransaction","error","result","response","_createJsonRpcResponse","sendSignedTransaction","userContract","getFromStorage","params","from","currentProvider","Error","prototype","getLoginMessageToSign","signer","engine","resolve","reject","formatMessage","INVALID_DATA","message","userAddress","toLowerCase","_getUserNonce","nonce","dataToSign","types","EIP712Domain","LoginMessage","domain","primaryType","getUserMessageToSign","rawTransaction","decodedTx","decodeTx","to","data","value","methodInfo","decodeMethod","DASHBOARD_DATA_MISMATCH","methodName","api","_logMessage","paramArray","push","_getParamValue","account","accounts","recoverTransaction","ERROR_RESPONSE","end","_getUserContractWallet","userContractWallet","USER_CONTRACT_NOT_FOUND","metaInfo","contractWallet","relayerPayment","token","DEFAULT_RELAYER_PAYMENT_TOKEN_ADDRESS","amount","DEFAULT_RELAYER_PAYMENT_AMOUNT","batchId","NONCE_BATCH_ID","_getUserContractNonce","parseInt","utils","toHex","txGas","gasLimit","toString","expiry","EXPIRY","baseGas","BASE_GAS","MetaInfo","RelayerPayment","MetaTransaction","BICONOMY_NOT_INITIALIZED","onEvent","type","callback","on","EVENT_NOT_SUPPORTED","id","jsonrpc","isHex","signature","API_NOT_FOUND","url","apiId","gasPrice","_sendTransaction","code","USER_NOT_LOGGED_IN","rawTx","nonceBatchId","INVALID_PAYLOAD","JSON","stringify","emit","withdrawFunds","receiverAddress","withdrawAmount","_getUserAccount","signTypedV3Method","defaults","headers","common","post","then","SUCCESS_RESPONSE","log","txHash","catch","flag","gas","console","info","USER_ACCOUNT_NOT_FOUND","contractABI","contract","Contract","parse","methods","apply","estimateGas","address","getNonceAPI","get","version2","SMART_CONTRACT_DATA_READY","getAPIInfoAPI","listApis","apiList","DAPP_API_DATA_READY","res","paramObj","match","input","scientificToDecimal","ACTION_COMPLETE","SUCCESS","getDappAPI","dappResponse","dapp","dappNetworkId","networkId","networkResponse","NETWORK_ID_NOT_FOUND","providerNetworkId","NETWORK_ID_MISMATCH","chainId","signatureTypesResult","systemInfo","relayHubAddress","getDAppInfoAPI","SMART_CONTRACT_NOT_FOUND","smartContractList","smartContracts","forEach","abiDecoder","addABI","abi","userLocalAccount","userLocalContract","undefined","toUpperCase","NO_DATA","DAPP_NOT_FOUND","promise","owner","accountLogin","_setLocalData","transactionHash","setInterval","getLoginTransactionReceipt","getTransactionReceipt","receipt","USER_CONTRACT_CREATION_FAILED","clearInterval","isReady","login","logout","removeFromStorage","getUserContract","userAddressFromStorage","getUserAccount","localStorage","setItem","removeItem","getItem","num","nsign","Math","sign","abs","test","zero","parts","String","split","e","pop","l","coeff_array","slice","Array","join","dec","module","exports"],"mappings":"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","sourcesContent":["const axios = require(\"axios\");\nconst Promise = require('promise');\nconst txDecoder = require('ethereum-tx-decoder');\nconst {config, RESPONSE_CODES, EVENTS, BICONOMY_RESPONSE_CODES, STATUS} = require('./config');\nconst DEFAULT_PAYLOAD_ID = \"99999999\";\nconst Web3 = require('web3');\nconst baseURL = config.baseURL;\nconst userLoginPath = config.userLoginPath;\nconst withdrawFundsUrl = config.withdrawFundsUrl;\nconst getUserContractPath = config.getUserContractPath;\nconst JSON_RPC_VERSION = config.JSON_RPC_VERSION;\nconst USER_ACCOUNT = config.USER_ACCOUNT;\nconst USER_CONTRACT = config.USER_CONTRACT;\nconst NATIVE_META_TX_URL = config.nativeMetaTxUrl;\n\nlet decoderMap = {}, smartContractMap = {};\nlet web3;\nconst events = require('events');\nvar eventEmitter = new events.EventEmitter();\nlet loginInterval;\n\nlet domainType, metaInfoType, relayerPaymentType, metaTransactionType;\n\nlet domainData = {\n    name: config.eip712DomainName,\n    version: config.eip712SigVersion,\n    verifyingContract: config.eip712VerifyingContract\n};\n\n// EIP712 format data for login\nlet loginDomainType, loginMessageType, loginDomainData;\n\nfunction Biconomy(provider, options) {\n\t_validate(options);\n\tthis.status = STATUS.INIT;\n\tthis.dappId = options.dappId;\n\tthis.apiKey = options.apiKey;\n\tthis.isLogin = false;\n\tthis.dappAPIMap = {};\n\tthis.strictMode = options.strictMode || false;\n\tthis.providerId = options.providerId || 0;\n\tthis.readViaContract = options.readViaContract || false;\n\tthis.READY = STATUS.BICONOMY_READY;\n\tthis.LOGIN_CONFIRMATION = EVENTS.LOGIN_CONFIRMATION;\n\tthis.ERROR = EVENTS.BICONOMY_ERROR;\n\tthis.pendingLoginTransactions = {};\n\tif(options.debug) {\n\t\tconfig.logsEnabled = true;\n\t}\n\t_init(this.dappId, this.apiKey, this);\n\n\tif(provider) {\n\t\tweb3 = new Web3(provider);\n\t\tif(options.defaultAccount) {\n\t\t\tweb3.eth.defaultAccount = options.defaultAccount;\n\t\t}\n\t\tconst proto = Object.getPrototypeOf(provider)\n\t\tconst keys = Object.getOwnPropertyNames(proto)\n\n\t\tfor(var i=0;i<keys.length;i++){\n\t\t\tthis[keys[i]] = provider[keys[i]];\n\t\t}\n\n\t\tfor(var key in provider) {\n\t\t\tif(!this[key]) {\n\t\t\t\tthis[key] = provider[key];\n\t\t\t}\n\t\t}\n\n\t\tthis.providerSend = provider.send || provider.sendAsync;\n\t\tthis.send = function(payload, cb) {\n\t\t\tif(payload.method == 'eth_sendTransaction') {\n\n\t\t\t\thandleSendTransaction(this, payload, (error, result) => {\n\t\t\t\t\tlet response = _createJsonRpcResponse(payload, error, result);\n\t\t\t\t\tif(cb)  {\n\t\t\t\t\t\tcb(error, response);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t} else if(payload.method == 'eth_sendRawTransaction') {\n\n\t\t\t\tsendSignedTransaction(this, payload, (error, result) => {\n\t\t\t\t\tlet response = _createJsonRpcResponse(payload, error, result);\n\t\t\t\t\tif(cb) {\n\t\t\t\t\t\tcb(error, response);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t} else if(payload.method == 'eth_call') {\n\t\t\t\tlet userContract = getFromStorage(USER_CONTRACT);\n\t\t\t\tif(this.readViaContract && this.isLogin && userContract) {\n\t\t\t\t\tif(payload && payload.params && payload.params[0]) {\n\t\t\t\t\t\tpayload.params[0].from = userContract;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tweb3.currentProvider.send(payload, cb);\n\t\t\t} else {\n\t\t\t\tweb3.currentProvider.send(payload, cb);\n\t\t\t}\n\t\t};\n\t\tthis.sendAsync = this.send;\n\t} else {\n\t\tthrow new Error('Please pass a provider to Biconomy.');\n\t}\n}\n\n/**\n * This method returns an EIP712 formatted data ready to be signed\n * that will be used in login method/API.\n * LoginMessageType [\n * \t { name: \"userAddress\", type: \"address\"},\n *   { name: \"nonce\", type: \"uint256\"},\n *   { name: \"providerId\", type: \"string\"}\n * ]\n */\nBiconomy.prototype.getLoginMessageToSign = function(signer) {\n\tlet engine = this;\n\treturn new Promise(async (resolve, reject) => {\n\t\ttry {\n\t\t\tif(!signer || typeof signer != 'string') {\n\t\t\t\tlet response = formatMessage(RESPONSE_CODES.INVALID_DATA, \"signer parameter is mandatory and should be of type 'string'\");\n\t\t\t\treturn reject(response);\n\t\t\t}\n\t\t\tlet message = {};\n\t\t\tmessage.userAddress = signer.toLowerCase();\n\t\t\tmessage.providerId = engine.providerId\n\t\t\tlet nonce = await _getUserNonce(signer, this);\n\t\t\tif(!nonce) {\n\t\t\t\tnonce = 0;\n\t\t\t}\n\t\t\tmessage.nonce = nonce;\n\n\t\t\tconst dataToSign = {\n\t\t\t\ttypes: {\n\t\t\t\t\tEIP712Domain: loginDomainType,\n\t\t\t\t\tLoginMessage: loginMessageType\n\t\t\t\t},\n\t\t\t\tdomain: loginDomainData,\n\t\t\t\tprimaryType: \"LoginMessage\",\n\t\t\t\tmessage: message\n\t\t\t};\n\t\t\tresolve(dataToSign);\n\t\t} catch(error) {\n\t\t\treject(error);\n\t\t}\n\t});\n}\n\n/**\n * This method returns an EIP712 formatted data ready to be signed\n * that will be used while sending the transaction using web3.eth.sendSignedTransaction\n * Returned data structure types\n * RelayerPaymentType [\n *   { name: \"token\", type: \"address\"},\n *   { name: \"amount\", type: \"uint256\"}\n * ]\n\n * MetaTransactionType = [\n *\t{ name: \"from\", type: \"address\"},\n *\t{ name: \"to\", type: \"address\"},\n *\t{ name: \"data\", type: \"bytes\"},\n *\t{ name: \"batchId\", type: \"uint256\"},\n *\t{ name: \"nonce\", type: \"uint256\"},\n *\t{ name: \"expiry\", type: \"uint256\"},\n *\t{ name: \"txGas\", type: \"uint256\"},\n *\t{ name: \"baseGas\", type: \"uint256\"},\n *\t{ name: \"value\", type: \"uint256\"},\n *  { name: \"metaInfo\", type: \"MetaInfo\"},\n *  { name: \"relayerPayment\", type: \"RelayerPayment\"}\n * ]\n */\nBiconomy.prototype.getUserMessageToSign = function(rawTransaction, cb) {\n\tlet engine = this;\n\treturn new Promise(async (resolve, reject)=>{\n\n\t\tif(rawTransaction) {\n\t\t\tlet decodedTx = txDecoder.decodeTx(rawTransaction);\n\t\t\tif(decodedTx.to && decodedTx.data && decodedTx.value) {\n\t\t\t\tconst methodInfo = decodeMethod(decodedTx.to.toLowerCase(), decodedTx.data);\n\t\t\t\tif(!methodInfo) {\n\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.DASHBOARD_DATA_MISMATCH,\n\t\t\t\t\t\t`Smart Contract address registered on dashboard is different than what is sent(${decodedTx.to}) in current transaction`);\n\t\t\t\t\tif(cb) cb(error);\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\t\t\t\tlet methodName = methodInfo.name;\n\t\t\t\tlet api = engine.dappAPIMap[methodName];\n\t\t\t\tif(!api) {\n\t\t\t\t\t_logMessage(`API not found for method ${methodName}`);\n\n\t\t\t\t}\n\t\t\t\t_logMessage('API found');\n\t\t\t\tlet params = methodInfo.params;\n\t\t\t\tlet paramArray = [];\n\t\t\t\tfor(let i = 0; i < params.length; i++) {\n\t\t\t\t\tparamArray.push(_getParamValue(params[i]));\n\t\t\t\t}\n\n\t\t\t\tlet account = web3.eth.accounts.recoverTransaction(rawTransaction);\n\t\t\t\t_logMessage(`signer is ${account}`);\n\t\t\t\tif(!account) {\n\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.ERROR_RESPONSE ,`Not able to get user account from signed transaction`);\n\t\t\t\t\treturn end(error);\n\t\t\t\t}\n\n\t\t\t\tlet userContractWallet = await _getUserContractWallet(engine, account);\n\t\t\t\t_logMessage(`User contract wallet ${userContractWallet}`);\n\n\t\t\t\tif(!userContractWallet) {\n\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.USER_CONTRACT_NOT_FOUND ,`User contract wallet not found`);\n\t\t\t\t\tif(cb) cb(error);\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\tlet metaInfo = {};\n\t\t\t\tmetaInfo.contractWallet =  userContractWallet;\n\n\t\t\t\tlet relayerPayment = {};\n\t\t\t\trelayerPayment.token = config.DEFAULT_RELAYER_PAYMENT_TOKEN_ADDRESS;\n\t\t\t\trelayerPayment.amount = config.DEFAULT_RELAYER_PAYMENT_AMOUNT;\n\n\t\t\t\tlet message = {};\n\t\t\t\tmessage.from = account;\n\t\t\t\tmessage.to = decodedTx.to.toLowerCase();\n\t\t\t\tmessage.data = decodedTx.data;\n\t\t\t\tmessage.batchId = config.NONCE_BATCH_ID;\n\t\t\t\tlet nonce = await _getUserContractNonce(account,engine);\n\t\t\t\tmessage.nonce = parseInt(nonce);\n\t\t\t\tmessage.value = web3.utils.toHex(decodedTx.value);\n\t\t\t\tmessage.txGas = decodedTx.gasLimit.toString()?decodedTx.gasLimit.toString():0;\n\t\t\t\tmessage.expiry = config.EXPIRY;\n\t\t\t\tmessage.baseGas = config.BASE_GAS;\n\t\t\t\tmessage.metaInfo = metaInfo;\n\t\t\t\tmessage.relayerPayment = relayerPayment;\n\n\t\t\t\tconst dataToSign = {\n\t\t\t\t\ttypes: {\n\t\t\t\t\t\tEIP712Domain: domainType,\n\t\t\t\t\t\tMetaInfo: metaInfoType,\n\t\t\t\t\t\tRelayerPayment: relayerPaymentType,\n\t\t\t\t\t\tMetaTransaction: metaTransactionType\n\t\t\t\t\t},\n\t\t\t\t\tdomain: domainData,\n\t\t\t\t\tprimaryType: \"MetaTransaction\",\n\t\t\t\t\tmessage: message\n\t\t\t\t};\n\t\t\t\tif(cb) cb(null, dataToSign);\n\t\t\t\treturn resolve(dataToSign);\n\t\t\t} else {\n\t\t\t\tlet error = formatMessage(RESPONSE_CODES.BICONOMY_NOT_INITIALIZED ,\n\t\t\t\t\t`Decoders not initialized properly in mexa sdk. Make sure your have smart contracts registered on Mexa Dashboard`);\n\t\t\t\tif(cb) cb(error);\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t}\n\t});\n}\n\n/**\n * Method used to listen to events emitted from the SDK\n */\nBiconomy.prototype.onEvent = function(type, callback) {\n\tif(type == this.READY || type == this.ERROR || type == this.LOGIN_CONFIRMATION) {\n\t\teventEmitter.on(type, callback);\n\t\treturn this;\n\t} else {\n\t\tthrow formatMessage(RESPONSE_CODES.EVENT_NOT_SUPPORTED, `${type} event is not supported.`);\n\t}\n}\n\n/**\n * Create a JSON RPC response from the given error and result parameter.\n **/\nfunction _createJsonRpcResponse(payload, error, result) {\n\tlet response = {};\n\tresponse.id = payload.id;\n\tresponse.jsonrpc = JSON_RPC_VERSION;\n\tif(error) {\n\t\tresponse.error = error;\n\t} else if(result.error) {\n\t\tresponse.error = result.error;\n\t} else if(web3.utils.isHex(result)) {\n\t\tresponse.result = result;\n\t} else {\n\t\tresponse = result;\n\t}\n\treturn response;\n}\n\nfunction decodeMethod(to, data) {\n\tif(to && data && decoderMap[to]) {\n\t\treturn decoderMap[to].decodeMethod(data);\n\t}\n\treturn;\n}\n\n/**\n * Method used to handle transaction initiated using web3.eth.sendSignedTransaction method\n * It extracts rawTransaction from payload and decode it to get required information like from, to,\n * data, gasLimit to create the payload for biconomy meta transaction API.\n * In case of Native meta transaction, payload just contains rawTransaction\n * In case of contract based meta transaction, payload contains rawTransaction and signature wrapped\n * in a json object.\n *\n * @param {Object} engine Reference to this SDK instance\n * @param {Object} payload Payload data\n * @param {Function} end Callback function with error as first argument\n */\nasync function sendSignedTransaction(engine, payload, end) {\n\n\tif(payload && payload.params[0]) {\n\t\tlet data = payload.params[0];\n\t\tlet rawTransaction, signature;\n\n\t\tif(typeof data == \"string\") {\n\t\t\t// Here user send the rawTransaction in the payload directly. Probably the case of native meta transaction\n\t\t\trawTransaction = data;\n\t\t} else if(typeof data == \"object\") {\n\t\t\t// Here user wrapped raw Transaction in json object along with signature\n\t\t\tsignature = data.signature;\n\t\t\trawTransaction = data.rawTransaction;\n\t\t}\n\n\t\tif(rawTransaction) {\n\t\t\tlet decodedTx = txDecoder.decodeTx(rawTransaction);\n\n\t\t\tif(decodedTx.to && decodedTx.data && decodedTx.value) {\n\t\t\t\tconst methodInfo = decodeMethod(decodedTx.to.toLowerCase(), decodedTx.data);\n\t\t\t\tif(!methodInfo) {\n\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.DASHBOARD_DATA_MISMATCH,\n\t\t\t\t\t\t`Smart Contract address registered on dashboard is different than what is sent(${decodedTx.to}) in current transaction`);\n\t\t\t\t\treturn end(error);\n\t\t\t\t}\n\t\t\t\tlet methodName = methodInfo.name;\n\t\t\t\tlet api = engine.dappAPIMap[methodName];\n\t\t\t\tif(!api) {\n\t\t\t\t\t_logMessage(`API not found for method ${methodName}`);\n\t\t\t\t\t_logMessage(`Strict mode ${engine.strictMode}`);\n\t\t\t\t\tif(engine.strictMode) {\n\t\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.API_NOT_FOUND,\n\t\t\t\t\t\t\t`Biconomy strict mode is on. No registered API found for method ${methodName}. Please register API from developer dashboard.`);\n\t\t\t\t\t\treturn end(error, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_logMessage(`Falling back to default provider as strict mode is false in biconomy`);\n\t\t\t\t\t\treturn engine.providerSend(rawTransaction, end);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_logMessage('API found');\n\t\t\t\tlet params = methodInfo.params;\n\t\t\t\tlet paramArray = [];\n\t\t\t\tfor(let i = 0; i < params.length; i++) {\n\t\t\t\t\tparamArray.push(_getParamValue(params[i]));\n\t\t\t\t}\n\n\t\t\t\tlet account = web3.eth.accounts.recoverTransaction(rawTransaction);\n\t\t\t\t_logMessage(`signer is ${account}`);\n\t\t\t\tif(!account) {\n\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.ERROR_RESPONSE ,`Not able to get user account from signed transaction`);\n\t\t\t\t\treturn end(error);\n\t\t\t\t}\n\t\t\t\tif(api.url == NATIVE_META_TX_URL) {\n\t\t\t\t\tlet data = {};\n\t\t\t\t\tdata.userAddress = account;\n\t\t\t\t\tdata.apiId = api.id;\n\t\t\t\t\tdata.params = paramArray;\n\t\t\t\t\tdata.gasLimit = decodedTx.gasLimit.toString();\n\t\t\t\t\tdata.gasPrice = decodedTx.gasPrice.toString();\n\t\t\t\t\t_sendTransaction(engine, account, api, data, end);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(!engine.isLogin){\n\t\t\t\t\t\tlet error = {};\n\t\t\t\t\t\terror.message = 'User not logged in to biconomy';\n\t\t\t\t\t\terror.code = RESPONSE_CODES.USER_NOT_LOGGED_IN;\n\t\t\t\t\t\treturn end(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(signature ) {\n\n\t\t\t\t\t\t\tlet relayerPayment = {};\n\t\t\t\t\t\t\trelayerPayment.token = config.DEFAULT_RELAYER_PAYMENT_TOKEN_ADDRESS;\n\t\t\t\t\t\t\trelayerPayment.amount = config.DEFAULT_RELAYER_PAYMENT_AMOUNT;\n\n\t\t\t\t\t\t\tlet data = {};\n\t\t\t\t\t\t\tdata.rawTx = rawTransaction;\n\t\t\t\t\t\t\tdata.signature = signature;\n\t\t\t\t\t\t\tdata.to = decodedTx.to.toLowerCase();\n\t\t\t\t\t\t\tdata.from = account;\n\t\t\t\t\t\t\tdata.apiId = api.id;\n\t\t\t\t\t\t\tdata.data = decodedTx.data;\n\t\t\t\t\t\t\tdata.value = web3.utils.toHex(decodedTx.value)\n\t\t\t\t\t\t\tdata.gasLimit = decodedTx.gasLimit.toString();\n\t\t\t\t\t\t\tdata.gasPrice = decodedTx.gasPrice.toString();\n\t\t\t\t\t\t\tdata.nonceBatchId = config.NONCE_BATCH_ID;\n\t\t\t\t\t\t\tdata.expiry = config.EXPIRY;\n\t\t\t\t\t\t\tdata.baseGas = config.BASE_GAS;\n\t\t\t\t\t\t\tdata.relayerPayment = {\n\t\t\t\t\t\t\t\ttoken: relayerPayment.token,\n\t\t\t\t\t\t\t\tamount: relayerPayment.amount\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t_sendTransaction(engine, account, api, data, end);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.INVALID_PAYLOAD ,\n\t\t\t\t\t\t\t\t`Invalid payload data ${JSON.stringify(payload.params[0])}. message and signature are required in param object`);\n\t\t\t\t\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n\t\t\t\t\t\t\tend(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet error = formatMessage(RESPONSE_CODES.BICONOMY_NOT_INITIALIZED ,\n\t\t\t\t\t`Decoders not initialized properly in mexa sdk. Make sure your have smart contracts registered on Mexa Dashboard`);\n\t\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n\t\t\t\tend(error);\n\t\t\t}\n\t\t} else {\n\t\t\tlet error = formatMessage(RESPONSE_CODES.INVALID_PAYLOAD ,\n\t\t\t\t`Invalid payload data ${JSON.stringify(payload.params[0])}.rawTransaction is required in param object`);\n\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n\t\t\tend(error);\n\t\t}\n\t} else {\n\t\tlet error = formatMessage(RESPONSE_CODES.INVALID_PAYLOAD ,\n\t\t\t`Invalid payload data ${JSON.stringify(payload.params[0])}. Non empty Array expected in params key`);\n\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n\t\tend(error);\n\t}\n}\n\n/**\n * Method to withdraw ether from use contract wallets.\n * It takes the receiverAddress and withdraw amount in wei.\n * An optional callback parameter can also be given that has first parameter as error and\n * second parameter as result containing withdraw transaction hash.\n *\n * Returns a promise that resolves to result object containing withdraw transaction hash.\n */\nBiconomy.prototype.withdrawFunds = function(receiverAddress, withdrawAmount, cb) {\n\tlet engine = this;\n\treturn new Promise(async (resolve, reject)=>{\n\t\tlet account = await _getUserAccount(this);\n\t\tlet nonce = await _getUserContractNonce(account,this);\n\t\tlet userContractWallet = await _getUserContractWallet(engine, account);\n\t\tif(!userContractWallet) {\n\t\t\tlet error = formatMessage(RESPONSE_CODES.USER_CONTRACT_NOT_FOUND ,`User contract wallet not found`);\n\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n\t\t\tif(cb) cb(error);\n\t\t\treturn reject(error);\n\t\t}\n\t\tlet metaInfo = {};\n\t\tmetaInfo.contractWallet =  userContractWallet;\n\n\t\tlet relayerPayment = {};\n\t\trelayerPayment.token = config.DEFAULT_RELAYER_PAYMENT_TOKEN_ADDRESS;\n\t\trelayerPayment.amount = config.DEFAULT_RELAYER_PAYMENT_AMOUNT;\n\n\t\tlet message = {};\n\t\tmessage.from = account;\n\t\tmessage.to = receiverAddress;\n\t\tmessage.data = \"0x0\";\n\t\tmessage.batchId = config.NONCE_BATCH_ID;\n\t\tmessage.nonce = parseInt(nonce);\n\t\tmessage.value = web3.utils.toHex(withdrawAmount || 0);\n\t\tmessage.txGas = 0;\n\t\tmessage.expiry = config.EXPIRY;\n\t\tmessage.baseGas = config.BASE_GAS;\n\t\tmessage.metaInfo = metaInfo;\n\t\tmessage.relayerPayment = relayerPayment;\n\t\tconst dataToSign = JSON.stringify({\n\t\t\ttypes: {\n\t\t\t\tEIP712Domain: domainType,\n\t\t\t\tMetaInfo: metaInfoType,\n\t\t\t\tRelayerPayment: relayerPaymentType,\n\t\t\t\tMetaTransaction: metaTransactionType\n\t\t\t},\n\t\t\tdomain: domainData,\n\t\t\tprimaryType: \"MetaTransaction\",\n\t\t\tmessage: message\n\t\t});\n\n\t\ttry{\n\t\t\tweb3.currentProvider.send({\n\t\t\t\tjsonrpc: JSON_RPC_VERSION,\n\t\t\t\tid: DEFAULT_PAYLOAD_ID,\n\t\t\t\tmethod: config.signTypedV3Method,\n\t\t\t\tparams: [account, dataToSign]\n\t\t\t}, function(error, response) {\n\t\t\t\t_logMessage(`User signature for payload id ${DEFAULT_PAYLOAD_ID} is ${response.result}`);\n\t\t\t\tif(error) {\n\t\t\t\t\tif(cb){\n\t\t\t\t\t\tcb(error);\n\t\t\t\t\t}\n\t\t\t\t\treject(error);\n\t\t\t\t} else if(response && response.error) {\n\t\t\t\t\tif(cb) cb(response.error);\n\t\t\t\t\treject(response.error);\n\t\t\t\t} else if(response && response.result) {\n\t\t\t\t\tlet data = {};\n\t\t\t\t\tdata.signature = response.result;\n\t\t\t\t\tdata.to = receiverAddress;\n\t\t\t\t\tdata.value = web3.utils.toHex(withdrawAmount) || 0;\n\t\t\t\t\tdata.from = account;\n\t\t\t\t\tdata.data = \"0x0\";\n\t\t\t\t\tdata.expiry = config.EXPIRY;\n\t\t\t\t\tdata.baseGas = config.BASE_GAS;\n\t\t\t\t\tdata.gasLimit = 0;\n\t\t\t\t\tdata.nonceBatchId = config.NONCE_BATCH_ID;\n\t\t\t\t\tdata.relayerPayment = relayerPayment;\n\n\t\t\t\t\taxios.defaults.headers.common[\"x-api-key\"] = engine.apiKey;\n\t\t\t\t\taxios.post(`${baseURL}${withdrawFundsUrl}`, data)\n\t\t\t\t\t.then(function(response) {\n\t\t\t\t\t\tif(response && response.data) {\n\t\t\t\t\t\t\tif(cb) cb(null, response.data);\n\t\t\t\t\t\t\tlet result = formatMessage(RESPONSE_CODES.SUCCESS_RESPONSE,response.data.log);\n\t\t\t\t\t\t\tresult.txHash = response.data.txHash;\n\t\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, `Unable to get response for api ${withdrawFundsUrl}`);\n\t\t\t\t\t\t\tif(cb) cb(error);\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.catch(function(error) {\n\t\t\t\t\t\tif(cb) cb(formatMessage(error.flag,error.log));\n\t\t\t\t\t\treject(formatMessage(error.flag,error.log));\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t} catch(error) {\n\t\t\tif(cb) cb(error);\n\t\t\treject(error);\n\t\t}\n\t});\n}\n/**\n * Function decodes the parameter in payload and gets the user signature using eth_signTypedData_v3\n * method and send the request to biconomy for processing and call the callback method 'end'\n * with transaction hash.\n *\n * This is an internal function that is called while intercepting eth_sendTransaction RPC method call.\n **/\nasync function handleSendTransaction(engine, payload, end) {\n\t_logMessage('Handle transaction with payload');\n\t_logMessage(payload);\n\tif(payload.params && payload.params[0] && payload.params[0].to) {\n\t\tif(decoderMap[payload.params[0].to.toLowerCase()]) {\n\t\t\tconst methodInfo = decodeMethod(payload.params[0].to.toLowerCase(), payload.params[0].data);\n\t\t\tlet methodName = methodInfo.name;\n\t\t\tlet api = engine.dappAPIMap[methodName];\n\t\t\tlet gasPrice = payload.params[0].gasPrice;\n\t\t\tlet gasLimit = payload.params[0].gas;\n\t\t\t_logMessage(api);\n\n\t\t\tif(!api) {\n\t\t\t\t_logMessage(`API not found for method ${methodName}`);\n\t\t\t\t_logMessage(`Strict mode ${engine.strictMode}`);\n\t\t\t\tif(engine.strictMode) {\n\t\t\t\t\tlet error = {};\n\t\t\t\t\terror.code = RESPONSE_CODES.API_NOT_FOUND;\n\t\t\t\t\terror.message = `Biconomy strict mode is on. No registered API found for method ${methodName}. Please register API from developer dashboard.`;\n\t\t\t\t\treturn end(error, null);\n\t\t\t\t} else {\n\t\t\t\t\t_logMessage(`Falling back to default provider as strict mode is false in biconomy`);\n\t\t\t\t\treturn engine.providerSend(payload, end);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsole.info('API found');\n\t\t\tlet params = methodInfo.params;\n\t\t\tlet paramArray = [];\n\t\t\tfor(let i = 0; i < params.length; i++) {\n\t\t\t\tparamArray.push(_getParamValue(params[i]));\n\t\t\t}\n\n\t\t\tconsole.info(\"Getting user account\");\n\t\t\tlet account = await _getUserAccount(engine, payload);\n\t\t\tif(!account) {\n\t\t\t\treturn end(`Not able to get user account`);\n\t\t\t}\n\t\t\tconsole.info(`User account fetched`);\n\t\t\tif(api.url == NATIVE_META_TX_URL) {\n\t\t\t\tlet data = {};\n\t\t\t\tdata.userAddress = account;\n\t\t\t\tdata.apiId = api.id;\n\t\t\t\tdata.params = paramArray;\n\t\t\t\tdata.gasPrice = gasPrice;\n\t\t\t\tdata.gasLimit = gasLimit;\n\t\t\t\t_sendTransaction(engine, account, api, data, end);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(engine.isLogin) {\n\t\t\t\t\tlet nonce = await _getUserContractNonce(account, engine);\n\t\t\t\t\tif(!nonce) {\n\t\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.USER_ACCOUNT_NOT_FOUND ,`User is not a registered biconomy user`);\n\t\t\t\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n\t\t\t\t\t\tend(error);\n\t\t\t\t\t}\n\t\t\t\t\tlet userContractWallet = await _getUserContractWallet(engine, account);\n\n\t\t\t\t\tif(!userContractWallet) {\n\t\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.USER_CONTRACT_NOT_FOUND ,`User contract wallet not found`);\n\t\t\t\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n\t\t\t\t\t\treturn end(error);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if gas limit is present, it not calculate gas limit\n\t\t\t\t\tif(!gasLimit || parseInt(gasLimit) == 0) {\n\t\t\t\t\t\tlet contractABI = smartContractMap[payload.params[0].to.toLowerCase()];\n\t\t\t\t\t\tif(contractABI) {\n\t\t\t\t\t\t\tlet contract = new web3.eth.Contract(JSON.parse(contractABI), payload.params[0].to.toLowerCase());\n\t\t\t\t\t\t\tgasLimit = await contract.methods[methodName].apply(null, paramArray).estimateGas({from: userContractWallet});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet metaInfo = {};\n\t\t\t\t\tmetaInfo.contractWallet =  userContractWallet;\n\n\t\t\t\t\tlet relayerPayment = {};\n\t\t\t\t\trelayerPayment.token = config.DEFAULT_RELAYER_PAYMENT_TOKEN_ADDRESS;\n\t\t\t\t\trelayerPayment.amount = config.DEFAULT_RELAYER_PAYMENT_AMOUNT;\n\n\t\t\t\t\tlet message = {};\n\t\t\t\t\tmessage.from = account;\n\t\t\t\t\tmessage.to = payload.params[0].to.toLowerCase();\n\t\t\t\t\tmessage.data = payload.params[0].data;\n\t\t\t\t\tmessage.batchId = config.NONCE_BATCH_ID;\n\t\t\t\t\tmessage.nonce = parseInt(nonce);\n\t\t\t\t\tmessage.value = web3.utils.toHex(payload.params[0].value || 0);\n\t\t\t\t\tmessage.txGas = gasLimit?gasLimit:0;\n\t\t\t\t\tmessage.expiry = config.EXPIRY;\n\t\t\t\t\tmessage.baseGas = config.BASE_GAS;\n\t\t\t\t\tmessage.metaInfo = metaInfo;\n\t\t\t\t\tmessage.relayerPayment = relayerPayment;\n\n\t\t\t\t\tconst dataToSign = JSON.stringify({\n\t\t\t\t\t\ttypes: {\n\t\t\t\t\t\t\tEIP712Domain: domainType,\n\t\t\t\t\t\t\tMetaInfo: metaInfoType,\n\t\t\t\t\t\t\tRelayerPayment: relayerPaymentType,\n\t\t\t\t\t\t\tMetaTransaction: metaTransactionType\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdomain: domainData,\n\t\t\t\t\t\tprimaryType: \"MetaTransaction\",\n\t\t\t\t\t\tmessage: message\n\t\t\t\t\t});\n\t\t\t\t\tconsole.debug(dataToSign);\n\t\t\t\t\tengine.send({\n\t\t\t\t\t\tjsonrpc: JSON_RPC_VERSION,\n\t\t\t\t\t\tid: payload.id,\n\t\t\t\t\t\tmethod: config.signTypedV3Method,\n\t\t\t\t\t\tparams: [account, dataToSign]\n\t\t\t\t\t}, function(error, response) {\n\t\t\t\t\t\tconsole.info(`User signature for payload id ${payload.id} is ${response.result}`);\n\t\t\t\t\t\tif(error) {\n\t\t\t\t\t\t\tend(error);\n\t\t\t\t\t\t} else if(response && response.error) {\n\t\t\t\t\t\t\tend(response.error);\n\t\t\t\t\t\t} else if(response && response.result) {\n\t\t\t\t\t\t\tlet data = {};\n\t\t\t\t\t\t\tdata.signature = response.result;\n\t\t\t\t\t\t\tdata.from = account;\n\t\t\t\t\t\t\tdata.to = payload.params[0].to.toLowerCase();\n\t\t\t\t\t\t\tdata.apiId = api.id;\n\t\t\t\t\t\t\tdata.dappId = engine.dappId;\n\n\t\t\t\t\t\t\tdata.data = payload.params[0].data;\n\t\t\t\t\t\t\tdata.nonceBatchId = config.NONCE_BATCH_ID;\n\t\t\t\t\t\t\tdata.expiry = config.EXPIRY;\n\t\t\t\t\t\t\tdata.baseGas = config.BASE_GAS;\n\t\t\t\t\t\t\tdata.userContract = userContractWallet;\n\t\t\t\t\t\t\tdata.value = web3.utils.toHex(payload.params[0].value || 0);\n\t\t\t\t\t\t\tdata.gasPrice = gasPrice;\n\t\t\t\t\t\t\tdata.gasLimit = gasLimit?gasLimit:0;\n\t\t\t\t\t\t\tdata.relayerPayment = {\n\t\t\t\t\t\t\t\ttoken: relayerPayment.token,\n\t\t\t\t\t\t\t\tamount: relayerPayment.amount\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t_sendTransaction(engine, account, api, data, end);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tend();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tlet error = {};\n\t\t\t\t\terror.message = 'User not logged in to biconomy';\n\t\t\t\t\terror.code = RESPONSE_CODES.USER_NOT_LOGGED_IN;\n\t\t\t\t\treturn end(error);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlet error = formatMessage(RESPONSE_CODES.BICONOMY_NOT_INITIALIZED ,\n\t\t\t\t`Decoders not initialized properly in mexa sdk. Make sure your have smart contracts registered on Mexa Dashboard`);\n\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n\t\t\tend(error);\n\t\t}\n\t} else {\n\t\tlet error = formatMessage(RESPONSE_CODES.INVALID_PAYLOAD ,\n\t\t\t`Invalid payload data ${JSON.stringify(payload)}. Expecting params key to be an array with first element having a 'to' property`);\n\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n\t\tend(error);\n\t}\n}\n\n/**\n * It fetches the user nonce used during login.\n *\n * @param {string} address User address whole nonce is requested\n * @param {object} engine Reference to Mexa object.\n */\nasync function _getUserNonce(address, engine) {\n\ttry {\n\t\tlet getNonceAPI = `${baseURL}/api/${config.version}/dapp-user/getNonce?signer=${address}`;\n\t\taxios.defaults.headers.common[\"x-api-key\"] = engine.apiKey;\n\t\tlet response = await axios.get(getNonceAPI);\n\t\tif(response && response.status == 200 && response.data) {\n\t\t\treturn response.data.nonce;\n\t\t}\n\t\treturn;\n\t} catch(error) {\n\t\tif(error.response.status == 404) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn;\n\t}\n}\n\n/**\n * It query biconomy server for user contract nonce.\n *\n * @param {string} address user address whole nonce is requested\n * @param {object} engine Reference to mexa object\n */\nasync function _getUserContractNonce(address, engine) {\n\ttry {\n\t\tlet getNonceAPI = `${baseURL}/api/${config.version2}/dapp-user/getContractNonce?signer=${address}`;\n\t\taxios.defaults.headers.common[\"x-api-key\"] = engine.apiKey;\n\t\tlet response = await axios.get(getNonceAPI);\n\t\tif(response && response.status == 200 && response.data) {\n\t\t\treturn response.data.nonce;\n\t\t}\n\t\treturn;\n\t} catch(error) {\n\t\t_logMessage(error);\n\t\treturn;\n\t}\n}\n\n\n// On getting smart contract data get the API data also\neventEmitter.on(EVENTS.SMART_CONTRACT_DATA_READY, (dappId, engine)=>{\n\t// Get DApp API information from Database\n    let getAPIInfoAPI = `${baseURL}/api/${config.version}/meta-api?dappId=${dappId}`;\n\taxios.get(getAPIInfoAPI).then(function(response) {\n\t\tif(response && response.data && response.data.listApis) {\n\t\t\tlet apiList = response.data.listApis;\n\t\t\tfor(let i=0;i<apiList.length;i++) {\n\t\t\t\tengine.dappAPIMap[apiList[i].method] = apiList[i];\n\t\t\t}\n\t\t\teventEmitter.emit(EVENTS.DAPP_API_DATA_READY, engine);\n\t\t}\n\t}).catch(function(error) {\n      console.error(error);\n    });\n});\n\neventEmitter.on(EVENTS.DAPP_API_DATA_READY, (engine)=>{\n\tengine.status = STATUS.BICONOMY_READY;\n\teventEmitter.emit(STATUS.BICONOMY_READY);\n});\n\n/**\n * Get user account from current provider using eth_accounts method.\n **/\nfunction _getUserAccount(engine, payload, cb) {\n\tif(engine) {\n\t\tlet id = DEFAULT_PAYLOAD_ID;\n\t\tif(payload) {\n\t\t\tid = payload.id;\n\t\t}\n\t\tif(cb) {\n\t\t\tweb3.currentProvider.send({jsonrpc: JSON_RPC_VERSION, id: id, method: 'eth_accounts', params: []}, (error, response)=>{\n\t\t\t\tif(response && response.result && response.result.length == 0\n\t\t\t\t\t&& web3.eth.defaultAccount && web3.eth.defaultAccount != \"\") {\n\t\t\t\t\tresponse.result.push(web3.eth.defaultAccount);\n\t\t\t\t\tcb(error, response);\n\t\t\t\t} else {\n\t\t\t\t\tcb(error, response);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\treturn new Promise(function(resolve, reject) {\n\t\t\t\tweb3.currentProvider.send({jsonrpc: JSON_RPC_VERSION, id: id, method: 'eth_accounts', params: []}, function(error, res){\n\t\t\t\t\tif(error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else if(!res.result) {\n\t\t\t\t\t\treject(`Invalid response ${res}`);\n\t\t\t\t\t} else if(res.result && res.result.length == 0\n\t\t\t\t\t\t&& web3.eth.defaultAccount && web3.eth.defaultAccount != \"\") {\n\t\t\t\t\t\tresolve(web3.eth.defaultAccount);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(res.result[0]);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n}\n\n/**\n * Validate parameters passed to biconomy object. Dapp id and api key are mandatory.\n **/\nfunction _validate(options) {\n\tif(!options) {\n\t\tthrow new Error(`Options object needs to be passed to Biconomy Object with dappId and apiKey mandatory keys`);\n\t}\n\tif(!options.dappId || !options.apiKey) {\n\t\tthrow new Error(`dappId and apiKey are required in options object when creating Biconomy object`);\n\t}\n}\n\n/**\n * Get paramter value from param object based on its type.\n **/\nfunction _getParamValue(paramObj) {\n\tlet value;\n\tif(paramObj) {\n\t\tlet type = paramObj.type;\n\t\tswitch (type) {\n\t\t\tcase (type.match(/^uint/) || type.match(/^int/) || {}).input:\n\t\t\t\tvalue = scientificToDecimal(parseInt(paramObj.value));\n\t\t\t\tvalue = web3.utils.toHex(value);\n\t\t\t\tbreak;\n\t\t\tcase 'string':\n\t\t\t\tif(typeof paramObj.value === \"object\"){\n\t\t\t\t\tvalue = paramObj.value.toString();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = paramObj.value;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tvalue = paramObj.value;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn value;\n}\n\n/**\n * Method to send the transaction to biconomy server and call the callback method\n * to pass the result of meta transaction to web3 function call.\n * @param engine Object representing biconomy provider engine\n * @param account User selected account on current wallet\n * @param api API object got from biconomy server\n * @param data Data to be sent to biconomy server having transaction data\n * @param cb Callback method to be called to pass result or send error\n **/\nfunction _sendTransaction(engine, account, api, data, cb) {\n\tif(engine && account && api && data) {\n\t\tlet url = api.url;\n\t\taxios\n\t      .post(`${baseURL}${url}`, data)\n\t      .then(function(response) {\n\t\t\tif(response && response.data) {\n\t\t\t\tconst result = response.data;\n\t\t\t\t_logMessage(result);\n\t\t\t\tif(result.flag && result.flag != BICONOMY_RESPONSE_CODES.ACTION_COMPLETE\n\t\t\t\t\t&& result.flag != BICONOMY_RESPONSE_CODES.SUCCESS) {\n\t\t\t\t\tlet error = {};\n\t\t\t\t\terror.code = result.flag;\n\t\t\t\t\tif(result.flag == BICONOMY_RESPONSE_CODES.USER_CONTRACT_NOT_FOUND) {\n\t\t\t\t\t\terror.code = RESPONSE_CODES.USER_CONTRACT_NOT_FOUND;\n\t\t\t\t\t}\n\t\t\t\t\terror.message = result.log;\n\t\t\t\t\tif(cb) cb(error);\n\t\t\t\t} else {\n\t\t\t\t\tif(cb) cb(null, result.txHash);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_logMessage(response);\n\t\t\t\tif(cb) cb(formatMessage(RESPONSE_CODES.ERROR_RESPONSE, `Invalid response from api ${url}`));\n\t\t\t}\n\t      })\n\t      .catch(function(error) {\n\t        _logMessage(error);\n\t        if(cb) cb(error);\n\t      });\n\t} else {\n\t\t_logMessage(`Invalid arguments, provider: ${engine} account: ${account} api: ${api} data: ${data}`);\n\t\tif(cb) cb(`Invalid arguments, provider: ${engine} account: ${account} api: ${api} data: ${data}`, null);\n\t}\n}\n\n/**\n * Function to initialize the biconomy object with DApp information.\n * It fetches the dapp's smart contract from biconomy database and initialize the decoders for each smart\n * contract which will be used to decode information during function calls.\n * @param dappId Id for dapp whose information is to be fetched\n * @param apiKey API key used to authenticate the request at biconomy server\n * @param _this object representing biconomy provider\n **/\nasync function _init(dappId, apiKey, engine) {\n\ttry {\n\t\t// Check current network id and dapp network id registered on dashboard\n\t\tlet getDappAPI = `${baseURL}/api/${config.version}/dapp?dappId=${dappId}`;\n\t\taxios.defaults.headers.common[\"x-api-key\"] = apiKey;\n\t\taxios.get(getDappAPI).then(function(response) {\n\t\t\tlet dappResponse = response.data;\n\t\t\tif(dappResponse && dappResponse.dapp) {\n\t\t\t\tlet dappNetworkId = dappResponse.dapp.networkId;\n\t\t\t\t_logMessage(`Network id corresponding to dapp id ${dappId} is ${dappNetworkId}`);\n\t\t\t\tweb3.currentProvider.send({\n\t\t\t\t\tjsonrpc: JSON_RPC_VERSION,\n\t\t\t\t\tid: '102',\n\t\t\t\t\tmethod: 'net_version',\n\t\t\t\t\tparams: []\n\t\t\t\t}, function(error, networkResponse){\n\t\t\t\t\tif(error || (networkResponse && networkResponse.error)) {\n\t\t\t\t\t\treturn eventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\t\tformatMessage(RESPONSE_CODES.NETWORK_ID_NOT_FOUND , \"Could not get network version\"), error || networkResponse.error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet providerNetworkId = networkResponse.result;\n\t\t\t\t\t\t_logMessage(`Current provider network id: ${providerNetworkId}`);\n\t\t\t\t\t\tif(providerNetworkId != dappNetworkId) {\n\t\t\t\t\t\t\treturn eventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\t\t\tformatMessage(RESPONSE_CODES.NETWORK_ID_MISMATCH,\n\t\t\t\t\t\t\t\t`Current networkId ${providerNetworkId} is different from dapp network id registered on mexa dashboard ${dappNetworkId}`));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdomainData.chainId = providerNetworkId;\n\t\t\t\t\t\t\taxios.get(`${baseURL}/api/${config.version2}/meta-tx/systemInfo?networkId=${providerNetworkId}`)\n\t\t\t\t\t\t\t.then(signatureTypesResult => {\n\t\t\t\t\t\t\t\tif(signatureTypesResult && signatureTypesResult.data) {\n\t\t\t\t\t\t\t\t\tlet systemInfo = signatureTypesResult.data;\n\t\t\t\t\t\t\t\t\tdomainType = systemInfo.domainType;\n\t\t\t\t\t\t\t\t\tmetaInfoType = systemInfo.metaInfoType;\n\t\t\t\t\t\t\t\t\trelayerPaymentType = systemInfo.relayerPaymentType;\n\t\t\t\t\t\t\t\t\tmetaTransactionType = systemInfo.metaTransactionType;\n\t\t\t\t\t\t\t\t\tloginDomainType = systemInfo.loginDomainType;\n\t\t\t\t\t\t\t\t\tloginMessageType = systemInfo.loginMessageType;\n\t\t\t\t\t\t\t\t\tloginDomainData = systemInfo.loginDomainData;\n\n\t\t\t\t\t\t\t\t\tif(systemInfo.relayHubAddress) {\n\t\t\t\t\t\t\t\t\t\tdomainData.verifyingContract = systemInfo.relayHubAddress;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn eventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\t\t\t\t\tformatMessage(RESPONSE_CODES.INVALID_DATA ,\n\t\t\t\t\t\t\t\t\t\t\t\"Could not get signature types from server. Contact Biconomy Team\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Get dapps smart contract data from biconomy servers\n\t\t\t\t\t\t\t\tlet getDAppInfoAPI = `${baseURL}/api/${config.version}/smart-contract?dappId=${dappId}`;\n\t\t\t\t\t\t\t\taxios.get(getDAppInfoAPI).then(function(response) {\n\t\t\t\t\t\t\t\t\tlet result = response.data;\n\t\t\t\t\t\t\t\t\tif(!result && result.flag != 143) {\n\t\t\t\t\t\t\t\t\t\treturn eventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\t\t\t\t\t\tformatMessage(RESPONSE_CODES.SMART_CONTRACT_NOT_FOUND ,\n\t\t\t\t\t\t\t\t\t\t\t\t`Error getting smart contract for dappId ${dappId}`));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet smartContractList = result.smartContracts;\n\t\t\t\t\t\t\t\t\tif(smartContractList && smartContractList.length > 0) {\n\t\t\t\t\t\t\t\t\t\tsmartContractList.forEach(contract => {\n\t\t\t\t\t\t\t\t\t\t\tlet abiDecoder = require('abi-decoder');\n\t\t\t\t\t\t\t\t\t\t\tabiDecoder.addABI(JSON.parse(contract.abi));\n\t\t\t\t\t\t\t\t\t\t\tdecoderMap[contract.address.toLowerCase()] = abiDecoder;\n\t\t\t\t\t\t\t\t\t\t\tsmartContractMap[contract.address.toLowerCase()] = contract.abi;\n\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\tlet userLocalAccount = getFromStorage(USER_ACCOUNT);\n\t\t\t\t\t\t\t\t\t\tlet userLocalContract = getFromStorage(USER_CONTRACT);\n\t\t\t\t\t\t\t\t\t\tif(userLocalContract && userLocalAccount) {\n\t\t\t\t\t\t\t\t\t\t\t_getUserAccount(engine, undefined, (error, response) => {\n\t\t\t\t\t\t\t\t\t\t\t\tif(error || !response || response.error) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn eventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tformatMessage(RESPONSE_CODES.USER_ACCOUNT_NOT_FOUND ,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"Could not get user account\"));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tlet account = response.result[0];\n\t\t\t\t\t\t\t\t\t\t\t\t_getUserContractWallet(engine, account, (error, userContract) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(userContract && account && account.toUpperCase() == userLocalAccount.toUpperCase()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t&& userContract.toUpperCase() == userLocalContract.toUpperCase()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tengine.isLogin = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t_logMessage('Biconomy user login set to true');\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\teventEmitter.emit(EVENTS.SMART_CONTRACT_DATA_READY, dappId, engine);\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\teventEmitter.emit(EVENTS.SMART_CONTRACT_DATA_READY, dappId, engine);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tengine.status = STATUS.NO_DATA;\n\t\t\t\t\t\t\t\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\t\t\t\t\t\tformatMessage(RESPONSE_CODES.SMART_CONTRACT_NOT_FOUND ,\n\t\t\t\t\t\t\t\t\t\t\t\t`No smart contract registered for dappId ${dappId} on Mexa Dashboard`));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.catch(function(error) {\n\t\t\t\t\t\t\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\t\t\t\t\tformatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Error while initializing Biconomy\"), error);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif(dappResponse.log) {\n\t\t\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\tformatMessage(RESPONSE_CODES.ERROR_RESPONSE, dappResponse.log));\n\t\t\t\t} else {\n\t\t\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\tformatMessage(RESPONSE_CODES.DAPP_NOT_FOUND, `No Dapp Registered with dapp id ${dappId}`));\n\t\t\t\t}\n\t\t\t}\n\t\t}).catch(function(error) {\n\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\tformatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Error while initializing Biconomy\"), error);\n\t\t});\n\t} catch(error) {\n\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\tformatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Error while initializing Biconomy\"), error);\n\t}\n\n}\n\n/**\n * Method to get user contract wallet from biconomy server.\n **/\nasync function _getUserContractWallet(engine, address, cb) {\n\tlet promise = new Promise((resolve, reject) => {\n\t\tif(address) {\n\t\t\tengine.sendAsync({\n\t\t\t\tjsonrpc: JSON_RPC_VERSION,\n\t\t\t\tid: '102',\n\t\t\t\tmethod: 'net_version',\n\t\t\t\tparams: []\n\t\t\t}, function(error, response){\n\t\t\t\tif(error || (response && response.error)) {\n\t\t\t\t\tconsole.error(error || response.error);\n\t\t\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\tformatMessage(RESPONSE_CODES.NETWORK_ID_NOT_FOUND , \"Could not get network version\"), error || networkResponse.error);\n\t\t\t\t\treject(\"Could not get network version\");\n\t\t\t\t} else {\n\t\t\t\t\tlet networkId = response.result;\n\t\t\t\t\tlet data = {owner:address, networkId: networkId};\n\t\t\t\t\taxios\n\t\t\t\t\t  .get(`${baseURL}${getUserContractPath}`, {params: data})\n\t\t\t\t\t  .then(function(response) {\n\t\t\t\t\t\tconst data = response.data;\n\t\t\t\t\t\tconsole.debug(data);\n\t\t\t\t\t\tif(data.flag && data.flag == BICONOMY_RESPONSE_CODES.SUCCESS) {\n\t\t\t\t\t\t\tif(cb) {\n\t\t\t\t\t\t\t\tcb(null, data.userContract);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresolve(data.userContract);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(cb) {\n\t\t\t\t\t\t\t\tcb(\"User contract not found\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treject(\"User contract not found\");\n\t\t\t\t\t\t}\n\t\t\t\t\t  })\n\t\t\t\t\t  .catch(function(error) {\n\t\t\t\t\t\t_logMessage(error);\n\t\t\t\t\t\tlet response = formatMessage(RESPONSE_CODES.ERROR_RESPONSE,\n\t\t\t\t\t\t\t`Error while fetching user contract ${JSON.stringify(error)}`);\n\t\t\t\t\t\tif(cb) cb(response);\n\t\t\t\t\t\treject(response);\n\t\t\t\t\t  });\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tlet response = formatMessage(RESPONSE_CODES.INVALID_DATA, \"Input address is not valid\");\n\t\t\tif(cb) cb(response);\n\t\t\treject(response);\n\t\t}\n\t});\n\treturn promise;\n}\n\n/**\n * Function used to login user. This creates a smart contract wallet for new user and\n * just returns contract wallet address for existing user.\n *\n * This function should be used when you have access to user's private key.\n *\n * @param {string} signer User Externally Owned Account (EOA) address\n * @param {string} signature EIP712 formatted signature signed using signer address\n * @param {function} cb Optional callback method with error first parameter\n *\n * @returns A promise that resolves to response containg transaction hash for new user\n * and user contract wallet address for existing user.\n *\n * Refer to https://docs.biconomy.io for more details on how to use it.\n */\nBiconomy.prototype.accountLogin = async function(signer, signature, cb) {\n\tlet engine = this;\n\treturn new Promise(async (resolve, reject) => {\n\t\tlet data = {};\n\t\tdata.signature = signature;\n\t\tdata.from = signer;\n\t\tdata.providerId = engine.providerId;\n\t\taxios\n\t\t\t.post(`${baseURL}${userLoginPath}`, data)\n\t\t\t.then(function(response) {\n\t\t\t\tconst data = response?response.data:undefined;\n\t\t\t\t_logMessage(data);\n\t\t\t\tif(data) {\n\t\t\t\t\tlet result = {}\n\t\t\t\t\tif(data.flag && data.flag == BICONOMY_RESPONSE_CODES.ACTION_COMPLETE) {\n\t\t\t\t\t\tresult.code = RESPONSE_CODES.SUCCESS_RESPONSE;\n\t\t\t\t\t\tif(data.userContract) {\n\t\t\t\t\t\t\tresult.message = `User login successfull`;\n\t\t\t\t\t\t\tresult.userContract = data.userContract;\n\t\t\t\t\t\t\tengine.isLogin = true;\n\t\t\t\t\t\t\t_setLocalData(signer, data.userContract);\n\t\t\t\t\t\t} else if(data.transactionHash) {\n\t\t\t\t\t\t\tresult.message = `User contract creation initiated`;\n\t\t\t\t\t\t\tresult.transactionHash = data.transactionHash;\n\t\t\t\t\t\t\tloginInterval = setInterval(function(){\n\t\t\t\t\t\t\t\tgetLoginTransactionReceipt(engine,data.transactionHash,signer)\n\t\t\t\t\t\t\t}, 2000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cb) cb(null, result);\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.code = RESPONSE_CODES.ERROR_RESPONSE;\n\t\t\t\t\t\tresult.message = data.log;\n\t\t\t\t\t\tif(cb) cb(result, null);\n\t\t\t\t\t\treject(result);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, `Invalid response from api ${url}`);\n\t\t\t\t\tif(cb) cb(error);\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch(function(error) {\n\t\t\t\t_logMessage(error);\n\t\t\t\tcb(error, null);\n\t\t\t\treject(error);\n\t\t\t});\n\t});\n}\n\nconst getLoginTransactionReceipt = async (engine,txHash,userAddress) => {\n    var receipt = await web3.eth.getTransactionReceipt(txHash);\n    if(receipt){\n      \tif(receipt.status){\n        \tawait _getUserContractWallet(engine, userAddress, (error, userContract) => {\n\t\t\t\tif(!error && userContract) {\n\t\t\t\t\t_setLocalData(userAddress, userContract);\n\t\t\t\t\tengine.isLogin = true;\n\t\t\t\t\teventEmitter.emit(EVENTS.LOGIN_CONFIRMATION, \"User Contract wallet created Successfully\", userContract);\n\t\t\t\t}\n\t\t\t});\n      \t}\n      \telse if(!receipt.status){\n\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR,formatMessage(RESPONSE_CODES.USER_CONTRACT_CREATION_FAILED,\"User Contract wallet creation Failed\"));\n      \t}\n      \tif(loginInterval){\n        \tclearInterval(loginInterval);\n      \t}\n    }\n}\n\nBiconomy.prototype.isReady = function() {\n\treturn (this.status === STATUS.BICONOMY_READY);\n}\n\n/**\n * Method used to login to biconomy. It takes user's public address as input\n * and if user contract wallet is not found for the user then it deploys\n * new user contract for the user. It user contract already exists it just\n * resolve to the contract wallet address.\n *\n * @returns Promise object that resolve to either transactionHash info or Contract wallet address\n **/\nBiconomy.prototype.login = async function(signer, cb){\n\treturn new Promise(async (resolve, reject)=> {\n\t\tif(!signer || typeof signer != 'string') {\n\t\t\tlet response = formatMessage(RESPONSE_CODES.INVALID_DATA, \"signer parameter is mandatory and should be of type 'string'\");\n\t\t\tif(cb) cb(response);\n\t\t\treject(response);\n\t\t\treturn;\n\t\t}\n\t\tlet engine = this;\n\t\tlet message = {};\n\t\tmessage.userAddress = signer.toLowerCase();\n\t\tmessage.providerId = engine.providerId\n\t\tlet nonce = await _getUserNonce(signer, this);\n\t\tif(!nonce) {\n\t\t\tnonce = 0;\n\t\t}\n\t\tmessage.nonce = nonce;\n\n\t\tconst dataToSign = JSON.stringify({\n\t\t\ttypes: {\n\t\t\t\tEIP712Domain: loginDomainType,\n\t\t\t\tLoginMessage: loginMessageType\n\t\t\t},\n\t\t\tdomain: loginDomainData,\n\t\t\tprimaryType: \"LoginMessage\",\n\t\t\tmessage: message\n\t\t});\n\n\t\tconsole.debug(`Biconomy engine status ${engine.status}`);\n\t\tif(engine.status != STATUS.BICONOMY_READY) {\n\t\t\treturn cb(formatMessage(RESPONSE_CODES.BICONOMY_NOT_INITIALIZED,'Biconomy SDK is not initialized properly'));\n\t\t}\n\t\tweb3.currentProvider.sendAsync({\n\t\t\tjsonrpc: JSON_RPC_VERSION,\n\t\t\tid: '101',\n\t\t\tmethod: config.signTypedV3Method,\n\t\t\tparams: [signer, dataToSign]\n\t\t}, function(error, signature){\n\t\t\tif(error) {\n\t\t\t\tlet response = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, error);\n\t\t\t\tif(cb) cb(response);\n\t\t\t\treject(response);\n\t\t\t} else {\n\t\t\t\tlet data = {};\n\t\t\t\tdata.signature = signature.result;\n\t\t\t\tdata.from = signer;\n\t\t\t\tdata.providerId = engine.providerId;\n\t\t\t\taxios\n\t\t\t\t.post(`${baseURL}${userLoginPath}`, data)\n\t\t\t\t.then(function(response) {\n\t\t\t\t\tconst data = response.data;\n\t\t\t\t\tconsole.debug(data);\n\t\t\t\t\tlet result = {}\n\t\t\t\t\tif(data.flag && data.flag == BICONOMY_RESPONSE_CODES.ACTION_COMPLETE) {\n\t\t\t\t\t\tresult.code = RESPONSE_CODES.SUCCESS_RESPONSE;\n\t\t\t\t\t\tif(data.userContract) {\n\t\t\t\t\t\t\tresult.message = `User login successfull`;\n\t\t\t\t\t\t\tresult.userContract = data.userContract;\n\t\t\t\t\t\t\tengine.isLogin = true;\n\t\t\t\t\t\t\t_setLocalData(signer, data.userContract);\n\t\t\t\t\t\t} else if(data.transactionHash) {\n\t\t\t\t\t\t\tresult.message = `User contract creation initiated`;\n\t\t\t\t\t\t\tresult.transactionHash = data.transactionHash;\n\t\t\t\t\t\t\tloginInterval = setInterval(function(){\n\t\t\t\t\t\t\t\tgetLoginTransactionReceipt(engine,data.transactionHash,signer)\n\t\t\t\t\t\t\t}, 2000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cb) cb(null, result);\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.code = RESPONSE_CODES.ERROR_RESPONSE;\n\t\t\t\t\t\tresult.message = data.log;\n\t\t\t\t\t\tif(cb) cb(result, null);\n\t\t\t\t\t\treject(result);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.catch(function(error) {\n\t\t\t\t\tconsole.debug(error);\n\t\t\t\t\tlet response = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, error);\n\t\t\t\t\tif(cb) cb(response);\n\t\t\t\t\treject(response);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n};\n\n/**\n * Function used to logout user from biconomy. It clears any internal user state and local storage.\n */\nBiconomy.prototype.logout = function() {\n\tremoveFromStorage(USER_ACCOUNT);\n\tremoveFromStorage(USER_CONTRACT);\n\tthis.isLogin = false;\n}\n\n/**\n * Function to return user contract wallet address.\n *\n * @param {string} userAddress User address for which contract wallet is requested\n * @returns A promise that resolves to user contact wallet if it exists else error response.\n */\nBiconomy.prototype.getUserContract = async function(userAddress) {\n\tlet response;\n\tif(this.isLogin) {\n\t\tlet userAddressFromStorage = getFromStorage(USER_ACCOUNT);\n\t\tif(userAddressFromStorage && userAddress){\n\t\t\tif( userAddressFromStorage.toLowerCase() === userAddress.toLowerCase()) {\n\t\t\t\tresponse = formatMessage(RESPONSE_CODES.SUCCESS_RESPONSE, \"User Contract Wallet address fetched successfully\");\n\t\t\t\tresponse.userContract = getFromStorage(USER_CONTRACT);\n\t\t\t}\n\t\t\tif(!response) {\n\t\t\t\tlet userContract = await _getUserContractWallet(this, userAddress);\n\t\t\t\tif(userContract) {\n\t\t\t\t\tresponse = formatMessage(RESPONSE_CODES.SUCCESS_RESPONSE, \"User Contract Wallet address fetched successfully\");\n\t\t\t\t\tresponse.userContract = userContract;\n\t\t\t\t} else {\n\t\t\t\t\tresponse = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Unable to fetch User Contract Wallet\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tresponse = formatMessage(RESPONSE_CODES.USER_NOT_LOGGED_IN, \"Please login to biconomy first\");\n\t}\n\treturn response;\n}\n\nBiconomy.prototype.getUserAccount = async function() {\n\treturn await _getUserAccount(this);\n}\n\nfunction formatMessage(code, message) {\n\treturn {\n\t\tcode: code,\n\t\tmessage: message\n\t};\n}\n\n/**\n * Setting data in localstorage to check later if user contract and user account\n * already exists and user has already logged in to biconomy once.\n **/\nfunction _setLocalData(signer, userContract) {\n\tif(typeof localStorage != 'undefined') {\n\t\tif(signer && userContract) {\n\t\t\tlocalStorage.setItem(USER_ACCOUNT, signer);\n\t\t\tlocalStorage.setItem(USER_CONTRACT, userContract);\n\t\t}\n\t} else {\n\t\tthis[USER_ACCOUNT] = signer;\n\t\tthis[USER_CONTRACT] = userContract;\n\t}\n}\n\n\nfunction removeFromStorage(key) {\n\tif(typeof localStorage != 'undefined') {\n\t\tlocalStorage.removeItem(key);\n\t} else {\n\t\tthis[key] = null;\n\t}\n}\n\nfunction getFromStorage(key) {\n\tif(typeof localStorage != 'undefined') {\n\t\treturn localStorage.getItem(key);\n\t} else {\n\t\treturn this[key];\n\t}\n}\n\n/**\n * Single method to be used for logging purpose.\n *\n * @param {string} message Message to be logged\n */\nfunction _logMessage(message) {\n\tif(config && config.logsEnabled && console.log) {\n\t\tconsole.log(message);\n\t}\n}\n\nvar scientificToDecimal = function (num) {\n    var nsign = Math.sign(num);\n    //remove the sign\n    num = Math.abs(num);\n    //if the number is in scientific notation remove it\n    if (/\\d+\\.?\\d*e[\\+\\-]*\\d+/i.test(num)) {\n        var zero = '0',\n                parts = String(num).toLowerCase().split('e'), //split into coeff and exponent\n                e = parts.pop(), //store the exponential part\n                l = Math.abs(e), //get the number of zeros\n                sign = e / l,\n                coeff_array = parts[0].split('.');\n        if (sign === -1) {\n            l = l - coeff_array[0].length;\n            if (l < 0) {\n              num = coeff_array[0].slice(0, l) + '.' + coeff_array[0].slice(l) + (coeff_array.length === 2 ? coeff_array[1] : '');\n            }\n            else {\n              num = zero + '.' + new Array(l + 1).join(zero) + coeff_array.join('');\n            }\n        }\n        else {\n            var dec = coeff_array[1];\n            if (dec)\n                l = l - dec.length;\n            if (l < 0) {\n\t\t\t  num\n\t\t\t  = coeff_array[0] + dec.slice(0, l) + '.' + dec.slice(l);\n            } else {\n              num = coeff_array.join('') + new Array(l + 1).join(zero);\n            }\n        }\n    }\n    return nsign < 0 ? '-'+num : num;\n};\n\nmodule.exports = Biconomy\n"]},"metadata":{},"sourceType":"script"}