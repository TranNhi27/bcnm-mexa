{"ast":null,"code":"const axios = require(\"axios\");\n\nconst Promise = require('promise');\n\nconst txDecoder = require('ethereum-tx-decoder');\n\nconst {\n  config,\n  RESPONSE_CODES,\n  EVENTS,\n  BICONOMY_RESPONSE_CODES,\n  STATUS\n} = require('./config');\n\nconst DEFAULT_PAYLOAD_ID = \"99999999\";\n\nconst Web3 = require('web3');\n\nconst baseURL = config.baseURL;\nconst userLoginPath = config.userLoginPath;\nconst withdrawFundsUrl = config.withdrawFundsUrl;\nconst getUserContractPath = config.getUserContractPath;\nconst JSON_RPC_VERSION = config.JSON_RPC_VERSION;\nconst USER_ACCOUNT = config.USER_ACCOUNT;\nconst USER_CONTRACT = config.USER_CONTRACT;\nconst NATIVE_META_TX_URL = config.nativeMetaTxUrl;\nlet decoderMap = {},\n    smartContractMap = {};\nlet web3;\n\nconst events = require('events');\n\nvar eventEmitter = new events.EventEmitter();\nlet loginInterval;\nlet domainType, metaInfoType, relayerPaymentType, metaTransactionType;\nlet domainData = {\n  name: config.eip712DomainName,\n  version: config.eip712SigVersion,\n  verifyingContract: config.eip712VerifyingContract\n}; // EIP712 format data for login\n\nlet loginDomainType, loginMessageType, loginDomainData;\n\nfunction Biconomy(provider, options) {\n  _validate(options);\n\n  this.status = STATUS.INIT;\n  this.dappId = options.dappId;\n  this.apiKey = options.apiKey;\n  this.isLogin = false;\n  this.dappAPIMap = {};\n  this.strictMode = options.strictMode || false;\n  this.providerId = options.providerId || 0;\n  this.readViaContract = options.readViaContract || false;\n  this.READY = STATUS.BICONOMY_READY;\n  this.LOGIN_CONFIRMATION = EVENTS.LOGIN_CONFIRMATION;\n  this.ERROR = EVENTS.BICONOMY_ERROR;\n  this.pendingLoginTransactions = {};\n\n  if (options.debug) {\n    config.logsEnabled = true;\n  }\n\n  _init(this.dappId, this.apiKey, this);\n\n  if (provider) {\n    web3 = new Web3(provider);\n\n    if (options.defaultAccount) {\n      web3.eth.defaultAccount = options.defaultAccount;\n    }\n\n    const proto = Object.getPrototypeOf(provider);\n    const keys = Object.getOwnPropertyNames(proto);\n\n    for (var i = 0; i < keys.length; i++) {\n      this[keys[i]] = provider[keys[i]];\n    }\n\n    for (var key in provider) {\n      if (!this[key]) {\n        this[key] = provider[key];\n      }\n    }\n\n    this.providerSend = provider.send || provider.sendAsync;\n\n    this.send = function (payload, cb) {\n      if (payload.method == 'eth_sendTransaction') {\n        handleSendTransaction(this, payload, (error, result) => {\n          let response = _createJsonRpcResponse(payload, error, result);\n\n          if (cb) {\n            cb(error, response);\n          }\n        });\n      } else if (payload.method == 'eth_sendRawTransaction') {\n        sendSignedTransaction(this, payload, (error, result) => {\n          let response = _createJsonRpcResponse(payload, error, result);\n\n          if (cb) {\n            cb(error, response);\n          }\n        });\n      } else if (payload.method == 'eth_call') {\n        let userContract = getFromStorage(USER_CONTRACT);\n\n        if (this.readViaContract && this.isLogin && userContract) {\n          if (payload && payload.params && payload.params[0]) {\n            payload.params[0].from = userContract;\n          }\n        }\n\n        web3.currentProvider.send(payload, cb);\n      } else {\n        web3.currentProvider.send(payload, cb);\n      }\n    };\n\n    this.sendAsync = this.send;\n  } else {\n    throw new Error('Please pass a provider to Biconomy.');\n  }\n}\n/**\n * This method returns an EIP712 formatted data ready to be signed\n * that will be used in login method/API.\n * LoginMessageType [\n * \t { name: \"userAddress\", type: \"address\"},\n *   { name: \"nonce\", type: \"uint256\"},\n *   { name: \"providerId\", type: \"string\"}\n * ]\n */\n\n\nBiconomy.prototype.getLoginMessageToSign = function (signer) {\n  let engine = this;\n  return new Promise(async (resolve, reject) => {\n    try {\n      if (!signer || typeof signer != 'string') {\n        let response = formatMessage(RESPONSE_CODES.INVALID_DATA, \"signer parameter is mandatory and should be of type 'string'\");\n        return reject(response);\n      }\n\n      let message = {};\n      message.userAddress = signer.toLowerCase();\n      message.providerId = engine.providerId;\n      let nonce = await _getUserNonce(signer, this);\n\n      if (!nonce) {\n        nonce = 0;\n      }\n\n      message.nonce = nonce;\n      const dataToSign = {\n        types: {\n          EIP712Domain: loginDomainType,\n          LoginMessage: loginMessageType\n        },\n        domain: loginDomainData,\n        primaryType: \"LoginMessage\",\n        message: message\n      };\n      resolve(dataToSign);\n    } catch (error) {\n      reject(error);\n    }\n  });\n};\n/**\n * This method returns an EIP712 formatted data ready to be signed\n * that will be used while sending the transaction using web3.eth.sendSignedTransaction\n * Returned data structure types\n * RelayerPaymentType [\n *   { name: \"token\", type: \"address\"},\n *   { name: \"amount\", type: \"uint256\"}\n * ]\n\n * MetaTransactionType = [\n *\t{ name: \"from\", type: \"address\"},\n *\t{ name: \"to\", type: \"address\"},\n *\t{ name: \"data\", type: \"bytes\"},\n *\t{ name: \"batchId\", type: \"uint256\"},\n *\t{ name: \"nonce\", type: \"uint256\"},\n *\t{ name: \"expiry\", type: \"uint256\"},\n *\t{ name: \"txGas\", type: \"uint256\"},\n *\t{ name: \"baseGas\", type: \"uint256\"},\n *\t{ name: \"value\", type: \"uint256\"},\n *  { name: \"metaInfo\", type: \"MetaInfo\"},\n *  { name: \"relayerPayment\", type: \"RelayerPayment\"}\n * ]\n */\n\n\nBiconomy.prototype.getUserMessageToSign = function (rawTransaction, cb) {\n  let engine = this;\n  return new Promise(async (resolve, reject) => {\n    if (rawTransaction) {\n      let decodedTx = txDecoder.decodeTx(rawTransaction);\n\n      if (decodedTx.to && decodedTx.data && decodedTx.value) {\n        const methodInfo = decodeMethod(decodedTx.to.toLowerCase(), decodedTx.data);\n\n        if (!methodInfo) {\n          let error = formatMessage(RESPONSE_CODES.DASHBOARD_DATA_MISMATCH, `Smart Contract address registered on dashboard is different than what is sent(${decodedTx.to}) in current transaction`);\n          if (cb) cb(error);\n          return reject(error);\n        }\n\n        let methodName = methodInfo.name;\n        let api = engine.dappAPIMap[methodName];\n\n        if (!api) {\n          _logMessage(`API not found for method ${methodName}`);\n        }\n\n        _logMessage('API found');\n\n        let params = methodInfo.params;\n        let paramArray = [];\n\n        for (let i = 0; i < params.length; i++) {\n          paramArray.push(_getParamValue(params[i]));\n        }\n\n        let account = web3.eth.accounts.recoverTransaction(rawTransaction);\n\n        _logMessage(`signer is ${account}`);\n\n        if (!account) {\n          let error = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, `Not able to get user account from signed transaction`);\n          return end(error);\n        }\n\n        let userContractWallet = await _getUserContractWallet(engine, account);\n\n        _logMessage(`User contract wallet ${userContractWallet}`);\n\n        if (!userContractWallet) {\n          let error = formatMessage(RESPONSE_CODES.USER_CONTRACT_NOT_FOUND, `User contract wallet not found`);\n          if (cb) cb(error);\n          return reject(error);\n        }\n\n        let metaInfo = {};\n        metaInfo.contractWallet = userContractWallet;\n        let relayerPayment = {};\n        relayerPayment.token = config.DEFAULT_RELAYER_PAYMENT_TOKEN_ADDRESS;\n        relayerPayment.amount = config.DEFAULT_RELAYER_PAYMENT_AMOUNT;\n        let message = {};\n        message.from = account;\n        message.to = decodedTx.to.toLowerCase();\n        message.data = decodedTx.data;\n        message.batchId = config.NONCE_BATCH_ID;\n        let nonce = await _getUserContractNonce(account, engine);\n        message.nonce = parseInt(nonce);\n        message.value = web3.utils.toHex(decodedTx.value);\n        message.txGas = decodedTx.gasLimit.toString() ? decodedTx.gasLimit.toString() : 0;\n        message.expiry = config.EXPIRY;\n        message.baseGas = config.BASE_GAS;\n        message.metaInfo = metaInfo;\n        message.relayerPayment = relayerPayment;\n        const dataToSign = {\n          types: {\n            EIP712Domain: domainType,\n            MetaInfo: metaInfoType,\n            RelayerPayment: relayerPaymentType,\n            MetaTransaction: metaTransactionType\n          },\n          domain: domainData,\n          primaryType: \"MetaTransaction\",\n          message: message\n        };\n        if (cb) cb(null, dataToSign);\n        return resolve(dataToSign);\n      } else {\n        let error = formatMessage(RESPONSE_CODES.BICONOMY_NOT_INITIALIZED, `Decoders not initialized properly in mexa sdk. Make sure your have smart contracts registered on Mexa Dashboard`);\n        if (cb) cb(error);\n        return reject(error);\n      }\n    }\n  });\n};\n/**\n * Method used to listen to events emitted from the SDK\n */\n\n\nBiconomy.prototype.onEvent = function (type, callback) {\n  if (type == this.READY || type == this.ERROR || type == this.LOGIN_CONFIRMATION) {\n    eventEmitter.on(type, callback);\n    return this;\n  } else {\n    throw formatMessage(RESPONSE_CODES.EVENT_NOT_SUPPORTED, `${type} event is not supported.`);\n  }\n};\n/**\n * Create a JSON RPC response from the given error and result parameter.\n **/\n\n\nfunction _createJsonRpcResponse(payload, error, result) {\n  let response = {};\n  response.id = payload.id;\n  response.jsonrpc = JSON_RPC_VERSION;\n\n  if (error) {\n    response.error = error;\n  } else if (result.error) {\n    response.error = result.error;\n  } else if (web3.utils.isHex(result)) {\n    response.result = result;\n  } else {\n    response = result;\n  }\n\n  return response;\n}\n\nfunction decodeMethod(to, data) {\n  if (to && data && decoderMap[to]) {\n    return decoderMap[to].decodeMethod(data);\n  }\n\n  return;\n}\n/**\n * Method used to handle transaction initiated using web3.eth.sendSignedTransaction method\n * It extracts rawTransaction from payload and decode it to get required information like from, to,\n * data, gasLimit to create the payload for biconomy meta transaction API.\n * In case of Native meta transaction, payload just contains rawTransaction\n * In case of contract based meta transaction, payload contains rawTransaction and signature wrapped\n * in a json object.\n *\n * @param {Object} engine Reference to this SDK instance\n * @param {Object} payload Payload data\n * @param {Function} end Callback function with error as first argument\n */\n\n\nasync function sendSignedTransaction(engine, payload, end) {\n  if (payload && payload.params[0]) {\n    let data = payload.params[0];\n    let rawTransaction, signature;\n\n    if (typeof data == \"string\") {\n      // Here user send the rawTransaction in the payload directly. Probably the case of native meta transaction\n      rawTransaction = data;\n    } else if (typeof data == \"object\") {\n      // Here user wrapped raw Transaction in json object along with signature\n      signature = data.signature;\n      rawTransaction = data.rawTransaction;\n    }\n\n    if (rawTransaction) {\n      let decodedTx = txDecoder.decodeTx(rawTransaction);\n\n      if (decodedTx.to && decodedTx.data && decodedTx.value) {\n        const methodInfo = decodeMethod(decodedTx.to.toLowerCase(), decodedTx.data);\n\n        if (!methodInfo) {\n          let error = formatMessage(RESPONSE_CODES.DASHBOARD_DATA_MISMATCH, `Smart Contract address registered on dashboard is different than what is sent(${decodedTx.to}) in current transaction`);\n          return end(error);\n        }\n\n        let methodName = methodInfo.name;\n        let api = engine.dappAPIMap[methodName];\n\n        if (!api) {\n          _logMessage(`API not found for method ${methodName}`);\n\n          _logMessage(`Strict mode ${engine.strictMode}`);\n\n          if (engine.strictMode) {\n            let error = formatMessage(RESPONSE_CODES.API_NOT_FOUND, `Biconomy strict mode is on. No registered API found for method ${methodName}. Please register API from developer dashboard.`);\n            return end(error, null);\n          } else {\n            _logMessage(`Falling back to default provider as strict mode is false in biconomy`);\n\n            return engine.providerSend(rawTransaction, end);\n          }\n        }\n\n        _logMessage('API found');\n\n        let params = methodInfo.params;\n        let paramArray = [];\n\n        for (let i = 0; i < params.length; i++) {\n          paramArray.push(_getParamValue(params[i]));\n        }\n\n        let account = web3.eth.accounts.recoverTransaction(rawTransaction);\n\n        _logMessage(`signer is ${account}`);\n\n        if (!account) {\n          let error = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, `Not able to get user account from signed transaction`);\n          return end(error);\n        }\n\n        if (api.url == NATIVE_META_TX_URL) {\n          let data = {};\n          data.userAddress = account;\n          data.apiId = api.id;\n          data.params = paramArray;\n          data.gasLimit = decodedTx.gasLimit.toString();\n          data.gasPrice = decodedTx.gasPrice.toString();\n\n          _sendTransaction(engine, account, api, data, end);\n        } else {\n          if (!engine.isLogin) {\n            let error = {};\n            error.message = 'User not logged in to biconomy';\n            error.code = RESPONSE_CODES.USER_NOT_LOGGED_IN;\n            return end(error);\n          } else {\n            if (signature) {\n              let relayerPayment = {};\n              relayerPayment.token = config.DEFAULT_RELAYER_PAYMENT_TOKEN_ADDRESS;\n              relayerPayment.amount = config.DEFAULT_RELAYER_PAYMENT_AMOUNT;\n              let data = {};\n              data.rawTx = rawTransaction;\n              data.signature = signature;\n              data.to = decodedTx.to.toLowerCase();\n              data.from = account;\n              data.apiId = api.id;\n              data.data = decodedTx.data;\n              data.value = web3.utils.toHex(decodedTx.value);\n              data.gasLimit = decodedTx.gasLimit.toString();\n              data.gasPrice = decodedTx.gasPrice.toString();\n              data.nonceBatchId = config.NONCE_BATCH_ID;\n              data.expiry = config.EXPIRY;\n              data.baseGas = config.BASE_GAS;\n              data.relayerPayment = {\n                token: relayerPayment.token,\n                amount: relayerPayment.amount\n              };\n\n              _sendTransaction(engine, account, api, data, end);\n            } else {\n              let error = formatMessage(RESPONSE_CODES.INVALID_PAYLOAD, `Invalid payload data ${JSON.stringify(payload.params[0])}. message and signature are required in param object`);\n              eventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n              end(error);\n            }\n          }\n        }\n      } else {\n        let error = formatMessage(RESPONSE_CODES.BICONOMY_NOT_INITIALIZED, `Decoders not initialized properly in mexa sdk. Make sure your have smart contracts registered on Mexa Dashboard`);\n        eventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n        end(error);\n      }\n    } else {\n      let error = formatMessage(RESPONSE_CODES.INVALID_PAYLOAD, `Invalid payload data ${JSON.stringify(payload.params[0])}.rawTransaction is required in param object`);\n      eventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n      end(error);\n    }\n  } else {\n    let error = formatMessage(RESPONSE_CODES.INVALID_PAYLOAD, `Invalid payload data ${JSON.stringify(payload.params[0])}. Non empty Array expected in params key`);\n    eventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n    end(error);\n  }\n}\n/**\n * Method to withdraw ether from use contract wallets.\n * It takes the receiverAddress and withdraw amount in wei.\n * An optional callback parameter can also be given that has first parameter as error and\n * second parameter as result containing withdraw transaction hash.\n *\n * Returns a promise that resolves to result object containing withdraw transaction hash.\n */\n\n\nBiconomy.prototype.withdrawFunds = function (receiverAddress, withdrawAmount, cb) {\n  let engine = this;\n  return new Promise(async (resolve, reject) => {\n    let account = await _getUserAccount(this);\n    let nonce = await _getUserContractNonce(account, this);\n    let userContractWallet = await _getUserContractWallet(engine, account);\n\n    if (!userContractWallet) {\n      let error = formatMessage(RESPONSE_CODES.USER_CONTRACT_NOT_FOUND, `User contract wallet not found`);\n      eventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n      if (cb) cb(error);\n      return reject(error);\n    }\n\n    let metaInfo = {};\n    metaInfo.contractWallet = userContractWallet;\n    let relayerPayment = {};\n    relayerPayment.token = config.DEFAULT_RELAYER_PAYMENT_TOKEN_ADDRESS;\n    relayerPayment.amount = config.DEFAULT_RELAYER_PAYMENT_AMOUNT;\n    let message = {};\n    message.from = account;\n    message.to = receiverAddress;\n    message.data = \"0x0\";\n    message.batchId = config.NONCE_BATCH_ID;\n    message.nonce = parseInt(nonce);\n    message.value = web3.utils.toHex(withdrawAmount || 0);\n    message.txGas = 0;\n    message.expiry = config.EXPIRY;\n    message.baseGas = config.BASE_GAS;\n    message.metaInfo = metaInfo;\n    message.relayerPayment = relayerPayment;\n    const dataToSign = JSON.stringify({\n      types: {\n        EIP712Domain: domainType,\n        MetaInfo: metaInfoType,\n        RelayerPayment: relayerPaymentType,\n        MetaTransaction: metaTransactionType\n      },\n      domain: domainData,\n      primaryType: \"MetaTransaction\",\n      message: message\n    });\n\n    try {\n      web3.currentProvider.send({\n        jsonrpc: JSON_RPC_VERSION,\n        id: DEFAULT_PAYLOAD_ID,\n        method: config.signTypedV3Method,\n        params: [account, dataToSign]\n      }, function (error, response) {\n        _logMessage(`User signature for payload id ${DEFAULT_PAYLOAD_ID} is ${response.result}`);\n\n        if (error) {\n          if (cb) {\n            cb(error);\n          }\n\n          reject(error);\n        } else if (response && response.error) {\n          if (cb) cb(response.error);\n          reject(response.error);\n        } else if (response && response.result) {\n          let data = {};\n          data.signature = response.result;\n          data.to = receiverAddress;\n          data.value = web3.utils.toHex(withdrawAmount) || 0;\n          data.from = account;\n          data.data = \"0x0\";\n          data.expiry = config.EXPIRY;\n          data.baseGas = config.BASE_GAS;\n          data.gasLimit = 0;\n          data.nonceBatchId = config.NONCE_BATCH_ID;\n          data.relayerPayment = relayerPayment;\n          axios.defaults.headers.common[\"x-api-key\"] = engine.apiKey;\n          axios.post(`${baseURL}${withdrawFundsUrl}`, data).then(function (response) {\n            if (response && response.data) {\n              if (cb) cb(null, response.data);\n              let result = formatMessage(RESPONSE_CODES.SUCCESS_RESPONSE, response.data.log);\n              result.txHash = response.data.txHash;\n              resolve(result);\n            } else {\n              let error = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, `Unable to get response for api ${withdrawFundsUrl}`);\n              if (cb) cb(error);\n              reject(error);\n            }\n          }).catch(function (error) {\n            if (cb) cb(formatMessage(error.flag, error.log));\n            reject(formatMessage(error.flag, error.log));\n          });\n        }\n      });\n    } catch (error) {\n      if (cb) cb(error);\n      reject(error);\n    }\n  });\n};\n/**\n * Function decodes the parameter in payload and gets the user signature using eth_signTypedData_v3\n * method and send the request to biconomy for processing and call the callback method 'end'\n * with transaction hash.\n *\n * This is an internal function that is called while intercepting eth_sendTransaction RPC method call.\n **/\n\n\nasync function handleSendTransaction(engine, payload, end) {\n  _logMessage('Handle transaction with payload');\n\n  _logMessage(payload);\n\n  if (payload.params && payload.params[0] && payload.params[0].to) {\n    if (decoderMap[payload.params[0].to.toLowerCase()]) {\n      const methodInfo = decodeMethod(payload.params[0].to.toLowerCase(), payload.params[0].data);\n      let methodName = methodInfo.name;\n      let api = engine.dappAPIMap[methodName];\n      let gasPrice = payload.params[0].gasPrice;\n      let gasLimit = payload.params[0].gas;\n\n      _logMessage(api);\n\n      if (!api) {\n        _logMessage(`API not found for method ${methodName}`);\n\n        _logMessage(`Strict mode ${engine.strictMode}`);\n\n        if (engine.strictMode) {\n          let error = {};\n          error.code = RESPONSE_CODES.API_NOT_FOUND;\n          error.message = `Biconomy strict mode is on. No registered API found for method ${methodName}. Please register API from developer dashboard.`;\n          return end(error, null);\n        } else {\n          _logMessage(`Falling back to default provider as strict mode is false in biconomy`);\n\n          return engine.providerSend(payload, end);\n        }\n      }\n\n      console.info('API found');\n      let params = methodInfo.params;\n      let paramArray = [];\n\n      for (let i = 0; i < params.length; i++) {\n        paramArray.push(_getParamValue(params[i]));\n      }\n\n      console.info(\"Getting user account\");\n      let account = await _getUserAccount(engine, payload);\n\n      if (!account) {\n        return end(`Not able to get user account`);\n      }\n\n      console.info(`User account fetched`);\n\n      if (api.url == NATIVE_META_TX_URL) {\n        let data = {};\n        data.userAddress = account;\n        data.apiId = api.id;\n        data.params = paramArray;\n        data.gasPrice = gasPrice;\n        data.gasLimit = gasLimit;\n\n        _sendTransaction(engine, account, api, data, end);\n      } else {\n        if (engine.isLogin) {\n          let nonce = await _getUserContractNonce(account, engine);\n\n          if (!nonce) {\n            let error = formatMessage(RESPONSE_CODES.USER_ACCOUNT_NOT_FOUND, `User is not a registered biconomy user`);\n            eventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n            end(error);\n          }\n\n          let userContractWallet = await _getUserContractWallet(engine, account);\n\n          if (!userContractWallet) {\n            let error = formatMessage(RESPONSE_CODES.USER_CONTRACT_NOT_FOUND, `User contract wallet not found`);\n            eventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n            return end(error);\n          } // Check if gas limit is present, it not calculate gas limit\n\n\n          if (!gasLimit || parseInt(gasLimit) == 0) {\n            let contractABI = smartContractMap[payload.params[0].to.toLowerCase()];\n\n            if (contractABI) {\n              let contract = new web3.eth.Contract(JSON.parse(contractABI), payload.params[0].to.toLowerCase());\n              gasLimit = await contract.methods[methodName].apply(null, paramArray).estimateGas({\n                from: userContractWallet\n              });\n            }\n          }\n\n          let metaInfo = {};\n          metaInfo.contractWallet = userContractWallet;\n          let relayerPayment = {};\n          relayerPayment.token = config.DEFAULT_RELAYER_PAYMENT_TOKEN_ADDRESS;\n          relayerPayment.amount = config.DEFAULT_RELAYER_PAYMENT_AMOUNT;\n          let message = {};\n          message.from = account;\n          message.to = payload.params[0].to.toLowerCase();\n          message.data = payload.params[0].data;\n          message.batchId = config.NONCE_BATCH_ID;\n          message.nonce = parseInt(nonce);\n          message.value = web3.utils.toHex(payload.params[0].value || 0);\n          message.txGas = gasLimit ? gasLimit : 0;\n          message.expiry = config.EXPIRY;\n          message.baseGas = config.BASE_GAS;\n          message.metaInfo = metaInfo;\n          message.relayerPayment = relayerPayment;\n          const dataToSign = JSON.stringify({\n            types: {\n              EIP712Domain: domainType,\n              MetaInfo: metaInfoType,\n              RelayerPayment: relayerPaymentType,\n              MetaTransaction: metaTransactionType\n            },\n            domain: domainData,\n            primaryType: \"MetaTransaction\",\n            message: message\n          });\n          console.debug(dataToSign);\n          engine.send({\n            jsonrpc: JSON_RPC_VERSION,\n            id: payload.id,\n            method: config.signTypedV3Method,\n            params: [account, dataToSign]\n          }, function (error, response) {\n            console.info(`User signature for payload id ${payload.id} is ${response.result}`);\n\n            if (error) {\n              end(error);\n            } else if (response && response.error) {\n              end(response.error);\n            } else if (response && response.result) {\n              let data = {};\n              data.signature = response.result;\n              data.from = account;\n              data.to = payload.params[0].to.toLowerCase();\n              data.apiId = api.id;\n              data.dappId = engine.dappId;\n              data.data = payload.params[0].data;\n              data.nonceBatchId = config.NONCE_BATCH_ID;\n              data.expiry = config.EXPIRY;\n              data.baseGas = config.BASE_GAS;\n              data.userContract = userContractWallet;\n              data.value = web3.utils.toHex(payload.params[0].value || 0);\n              data.gasPrice = gasPrice;\n              data.gasLimit = gasLimit ? gasLimit : 0;\n              data.relayerPayment = {\n                token: relayerPayment.token,\n                amount: relayerPayment.amount\n              };\n\n              _sendTransaction(engine, account, api, data, end);\n            } else {\n              end();\n            }\n          });\n        } else {\n          let error = {};\n          error.message = 'User not logged in to biconomy';\n          error.code = RESPONSE_CODES.USER_NOT_LOGGED_IN;\n          return end(error);\n        }\n      }\n    } else {\n      let error = formatMessage(RESPONSE_CODES.BICONOMY_NOT_INITIALIZED, `Decoders not initialized properly in mexa sdk. Make sure your have smart contracts registered on Mexa Dashboard`);\n      eventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n      end(error);\n    }\n  } else {\n    let error = formatMessage(RESPONSE_CODES.INVALID_PAYLOAD, `Invalid payload data ${JSON.stringify(payload)}. Expecting params key to be an array with first element having a 'to' property`);\n    eventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n    end(error);\n  }\n}\n/**\n * It fetches the user nonce used during login.\n *\n * @param {string} address User address whole nonce is requested\n * @param {object} engine Reference to Mexa object.\n */\n\n\nasync function _getUserNonce(address, engine) {\n  try {\n    let getNonceAPI = `${baseURL}/api/${config.version}/dapp-user/getNonce?signer=${address}`;\n    axios.defaults.headers.common[\"x-api-key\"] = engine.apiKey;\n    let response = await axios.get(getNonceAPI);\n\n    if (response && response.status == 200 && response.data) {\n      return response.data.nonce;\n    }\n\n    return;\n  } catch (error) {\n    if (error.response.status == 404) {\n      return 0;\n    }\n\n    return;\n  }\n}\n/**\n * It query biconomy server for user contract nonce.\n *\n * @param {string} address user address whole nonce is requested\n * @param {object} engine Reference to mexa object\n */\n\n\nasync function _getUserContractNonce(address, engine) {\n  try {\n    let getNonceAPI = `${baseURL}/api/${config.version2}/dapp-user/getContractNonce?signer=${address}`;\n    axios.defaults.headers.common[\"x-api-key\"] = engine.apiKey;\n    let response = await axios.get(getNonceAPI);\n\n    if (response && response.status == 200 && response.data) {\n      return response.data.nonce;\n    }\n\n    return;\n  } catch (error) {\n    _logMessage(error);\n\n    return;\n  }\n} // On getting smart contract data get the API data also\n\n\neventEmitter.on(EVENTS.SMART_CONTRACT_DATA_READY, (dappId, engine) => {\n  // Get DApp API information from Database\n  let getAPIInfoAPI = `${baseURL}/api/${config.version}/meta-api?dappId=${dappId}`;\n  axios.get(getAPIInfoAPI).then(function (response) {\n    if (response && response.data && response.data.listApis) {\n      let apiList = response.data.listApis;\n\n      for (let i = 0; i < apiList.length; i++) {\n        engine.dappAPIMap[apiList[i].method] = apiList[i];\n      }\n\n      eventEmitter.emit(EVENTS.DAPP_API_DATA_READY, engine);\n    }\n  }).catch(function (error) {\n    console.error(error);\n  });\n});\neventEmitter.on(EVENTS.DAPP_API_DATA_READY, engine => {\n  engine.status = STATUS.BICONOMY_READY;\n  eventEmitter.emit(STATUS.BICONOMY_READY);\n});\n/**\n * Get user account from current provider using eth_accounts method.\n **/\n\nfunction _getUserAccount(engine, payload, cb) {\n  if (engine) {\n    let id = DEFAULT_PAYLOAD_ID;\n\n    if (payload) {\n      id = payload.id;\n    }\n\n    if (cb) {\n      web3.currentProvider.send({\n        jsonrpc: JSON_RPC_VERSION,\n        id: id,\n        method: 'eth_accounts',\n        params: []\n      }, (error, response) => {\n        if (response && response.result && response.result.length == 0 && web3.eth.defaultAccount && web3.eth.defaultAccount != \"\") {\n          response.result.push(web3.eth.defaultAccount);\n          cb(error, response);\n        } else {\n          cb(error, response);\n        }\n      });\n    } else {\n      return new Promise(function (resolve, reject) {\n        web3.currentProvider.send({\n          jsonrpc: JSON_RPC_VERSION,\n          id: id,\n          method: 'eth_accounts',\n          params: []\n        }, function (error, res) {\n          if (error) {\n            reject(error);\n          } else if (!res.result) {\n            reject(`Invalid response ${res}`);\n          } else if (res.result && res.result.length == 0 && web3.eth.defaultAccount && web3.eth.defaultAccount != \"\") {\n            resolve(web3.eth.defaultAccount);\n          } else {\n            resolve(res.result[0]);\n          }\n        });\n      });\n    }\n  }\n}\n/**\n * Validate parameters passed to biconomy object. Dapp id and api key are mandatory.\n **/\n\n\nfunction _validate(options) {\n  if (!options) {\n    throw new Error(`Options object needs to be passed to Biconomy Object with dappId and apiKey mandatory keys`);\n  }\n\n  if (!options.dappId || !options.apiKey) {\n    throw new Error(`dappId and apiKey are required in options object when creating Biconomy object`);\n  }\n}\n/**\n * Get paramter value from param object based on its type.\n **/\n\n\nfunction _getParamValue(paramObj) {\n  let value;\n\n  if (paramObj) {\n    let type = paramObj.type;\n\n    switch (type) {\n      case (type.match(/^uint/) || type.match(/^int/) || {}).input:\n        value = scientificToDecimal(parseInt(paramObj.value));\n        value = web3.utils.toHex(value);\n        break;\n\n      case 'string':\n        if (typeof paramObj.value === \"object\") {\n          value = paramObj.value.toString();\n        } else {\n          value = paramObj.value;\n        }\n\n        break;\n\n      default:\n        value = paramObj.value;\n        break;\n    }\n  }\n\n  return value;\n}\n/**\n * Method to send the transaction to biconomy server and call the callback method\n * to pass the result of meta transaction to web3 function call.\n * @param engine Object representing biconomy provider engine\n * @param account User selected account on current wallet\n * @param api API object got from biconomy server\n * @param data Data to be sent to biconomy server having transaction data\n * @param cb Callback method to be called to pass result or send error\n **/\n\n\nfunction _sendTransaction(engine, account, api, data, cb) {\n  if (engine && account && api && data) {\n    let url = api.url;\n    axios.post(`${baseURL}${url}`, data).then(function (response) {\n      if (response && response.data) {\n        const result = response.data;\n\n        _logMessage(result);\n\n        if (result.flag && result.flag != BICONOMY_RESPONSE_CODES.ACTION_COMPLETE && result.flag != BICONOMY_RESPONSE_CODES.SUCCESS) {\n          let error = {};\n          error.code = result.flag;\n\n          if (result.flag == BICONOMY_RESPONSE_CODES.USER_CONTRACT_NOT_FOUND) {\n            error.code = RESPONSE_CODES.USER_CONTRACT_NOT_FOUND;\n          }\n\n          error.message = result.log;\n          if (cb) cb(error);\n        } else {\n          if (cb) cb(null, result.txHash);\n        }\n      } else {\n        _logMessage(response);\n\n        if (cb) cb(formatMessage(RESPONSE_CODES.ERROR_RESPONSE, `Invalid response from api ${url}`));\n      }\n    }).catch(function (error) {\n      _logMessage(error);\n\n      if (cb) cb(error);\n    });\n  } else {\n    _logMessage(`Invalid arguments, provider: ${engine} account: ${account} api: ${api} data: ${data}`);\n\n    if (cb) cb(`Invalid arguments, provider: ${engine} account: ${account} api: ${api} data: ${data}`, null);\n  }\n}\n/**\n * Function to initialize the biconomy object with DApp information.\n * It fetches the dapp's smart contract from biconomy database and initialize the decoders for each smart\n * contract which will be used to decode information during function calls.\n * @param dappId Id for dapp whose information is to be fetched\n * @param apiKey API key used to authenticate the request at biconomy server\n * @param _this object representing biconomy provider\n **/\n\n\nasync function _init(dappId, apiKey, engine) {\n  try {\n    // Check current network id and dapp network id registered on dashboard\n    let getDappAPI = `${baseURL}/api/${config.version}/dapp?dappId=${dappId}`;\n    axios.defaults.headers.common[\"x-api-key\"] = apiKey;\n    axios.get(getDappAPI).then(function (response) {\n      let dappResponse = response.data;\n\n      if (dappResponse && dappResponse.dapp) {\n        let dappNetworkId = dappResponse.dapp.networkId;\n\n        _logMessage(`Network id corresponding to dapp id ${dappId} is ${dappNetworkId}`);\n\n        web3.currentProvider.send({\n          jsonrpc: JSON_RPC_VERSION,\n          id: '102',\n          method: 'net_version',\n          params: []\n        }, function (error, networkResponse) {\n          if (error || networkResponse && networkResponse.error) {\n            return eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.NETWORK_ID_NOT_FOUND, \"Could not get network version\"), error || networkResponse.error);\n          } else {\n            let providerNetworkId = networkResponse.result;\n\n            _logMessage(`Current provider network id: ${providerNetworkId}`);\n\n            if (providerNetworkId != dappNetworkId) {\n              return eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.NETWORK_ID_MISMATCH, `Current networkId ${providerNetworkId} is different from dapp network id registered on mexa dashboard ${dappNetworkId}`));\n            } else {\n              domainData.chainId = providerNetworkId;\n              axios.get(`${baseURL}/api/${config.version2}/meta-tx/systemInfo?networkId=${providerNetworkId}`).then(signatureTypesResult => {\n                if (signatureTypesResult && signatureTypesResult.data) {\n                  let systemInfo = signatureTypesResult.data;\n                  domainType = systemInfo.domainType;\n                  metaInfoType = systemInfo.metaInfoType;\n                  relayerPaymentType = systemInfo.relayerPaymentType;\n                  metaTransactionType = systemInfo.metaTransactionType;\n                  loginDomainType = systemInfo.loginDomainType;\n                  loginMessageType = systemInfo.loginMessageType;\n                  loginDomainData = systemInfo.loginDomainData;\n\n                  if (systemInfo.relayHubAddress) {\n                    domainData.verifyingContract = systemInfo.relayHubAddress;\n                  }\n                } else {\n                  return eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.INVALID_DATA, \"Could not get signature types from server. Contact Biconomy Team\"));\n                } // Get dapps smart contract data from biconomy servers\n\n\n                let getDAppInfoAPI = `${baseURL}/api/${config.version}/smart-contract?dappId=${dappId}`;\n                axios.get(getDAppInfoAPI).then(function (response) {\n                  let result = response.data;\n\n                  if (!result && result.flag != 143) {\n                    return eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.SMART_CONTRACT_NOT_FOUND, `Error getting smart contract for dappId ${dappId}`));\n                  }\n\n                  let smartContractList = result.smartContracts;\n\n                  if (smartContractList && smartContractList.length > 0) {\n                    smartContractList.forEach(contract => {\n                      let abiDecoder = require('abi-decoder');\n\n                      abiDecoder.addABI(JSON.parse(contract.abi));\n                      decoderMap[contract.address.toLowerCase()] = abiDecoder;\n                      smartContractMap[contract.address.toLowerCase()] = contract.abi;\n                    });\n                    let userLocalAccount = getFromStorage(USER_ACCOUNT);\n                    let userLocalContract = getFromStorage(USER_CONTRACT);\n\n                    if (userLocalContract && userLocalAccount) {\n                      _getUserAccount(engine, undefined, (error, response) => {\n                        if (error || !response || response.error) {\n                          return eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.USER_ACCOUNT_NOT_FOUND, \"Could not get user account\"));\n                        }\n\n                        let account = response.result[0];\n\n                        _getUserContractWallet(engine, account, (error, userContract) => {\n                          if (userContract && account && account.toUpperCase() == userLocalAccount.toUpperCase() && userContract.toUpperCase() == userLocalContract.toUpperCase()) {\n                            engine.isLogin = true;\n\n                            _logMessage('Biconomy user login set to true');\n                          }\n\n                          eventEmitter.emit(EVENTS.SMART_CONTRACT_DATA_READY, dappId, engine);\n                        });\n                      });\n                    } else {\n                      eventEmitter.emit(EVENTS.SMART_CONTRACT_DATA_READY, dappId, engine);\n                    }\n                  } else {\n                    engine.status = STATUS.NO_DATA;\n                    eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.SMART_CONTRACT_NOT_FOUND, `No smart contract registered for dappId ${dappId} on Mexa Dashboard`));\n                  }\n                }).catch(function (error) {\n                  eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Error while initializing Biconomy\"), error);\n                });\n              });\n            }\n          }\n        });\n      } else {\n        if (dappResponse.log) {\n          eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.ERROR_RESPONSE, dappResponse.log));\n        } else {\n          eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.DAPP_NOT_FOUND, `No Dapp Registered with dapp id ${dappId}`));\n        }\n      }\n    }).catch(function (error) {\n      eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Error while initializing Biconomy\"), error);\n    });\n  } catch (error) {\n    eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Error while initializing Biconomy\"), error);\n  }\n}\n/**\n * Method to get user contract wallet from biconomy server.\n **/\n\n\nasync function _getUserContractWallet(engine, address, cb) {\n  let promise = new Promise((resolve, reject) => {\n    if (address) {\n      engine.sendAsync({\n        jsonrpc: JSON_RPC_VERSION,\n        id: '102',\n        method: 'net_version',\n        params: []\n      }, function (error, response) {\n        if (error || response && response.error) {\n          console.error(error || response.error);\n          eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.NETWORK_ID_NOT_FOUND, \"Could not get network version\"), error || networkResponse.error);\n          reject(\"Could not get network version\");\n        } else {\n          let networkId = response.result;\n          let data = {\n            owner: address,\n            networkId: networkId\n          };\n          axios.get(`${baseURL}${getUserContractPath}`, {\n            params: data\n          }).then(function (response) {\n            const data = response.data;\n            console.debug(data);\n\n            if (data.flag && data.flag == BICONOMY_RESPONSE_CODES.SUCCESS) {\n              if (cb) {\n                cb(null, data.userContract);\n              }\n\n              resolve(data.userContract);\n            } else {\n              if (cb) {\n                cb(\"User contract not found\");\n              }\n\n              reject(\"User contract not found\");\n            }\n          }).catch(function (error) {\n            _logMessage(error);\n\n            let response = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, `Error while fetching user contract ${JSON.stringify(error)}`);\n            if (cb) cb(response);\n            reject(response);\n          });\n        }\n      });\n    } else {\n      let response = formatMessage(RESPONSE_CODES.INVALID_DATA, \"Input address is not valid\");\n      if (cb) cb(response);\n      reject(response);\n    }\n  });\n  return promise;\n}\n/**\n * Function used to login user. This creates a smart contract wallet for new user and\n * just returns contract wallet address for existing user.\n *\n * This function should be used when you have access to user's private key.\n *\n * @param {string} signer User Externally Owned Account (EOA) address\n * @param {string} signature EIP712 formatted signature signed using signer address\n * @param {function} cb Optional callback method with error first parameter\n *\n * @returns A promise that resolves to response containg transaction hash for new user\n * and user contract wallet address for existing user.\n *\n * Refer to https://docs.biconomy.io for more details on how to use it.\n */\n\n\nBiconomy.prototype.accountLogin = async function (signer, signature, cb) {\n  let engine = this;\n  return new Promise(async (resolve, reject) => {\n    let data = {};\n    data.signature = signature;\n    data.from = signer;\n    data.providerId = engine.providerId;\n    axios.post(`${baseURL}${userLoginPath}`, data).then(function (response) {\n      const data = response ? response.data : undefined;\n\n      _logMessage(data);\n\n      if (data) {\n        let result = {};\n\n        if (data.flag && data.flag == BICONOMY_RESPONSE_CODES.ACTION_COMPLETE) {\n          result.code = RESPONSE_CODES.SUCCESS_RESPONSE;\n\n          if (data.userContract) {\n            result.message = `User login successfull`;\n            result.userContract = data.userContract;\n            engine.isLogin = true;\n\n            _setLocalData(signer, data.userContract);\n          } else if (data.transactionHash) {\n            result.message = `User contract creation initiated`;\n            result.transactionHash = data.transactionHash;\n            loginInterval = setInterval(function () {\n              getLoginTransactionReceipt(engine, data.transactionHash, signer);\n            }, 2000);\n          }\n\n          if (cb) cb(null, result);\n          resolve(result);\n        } else {\n          result.code = RESPONSE_CODES.ERROR_RESPONSE;\n          result.message = data.log;\n          if (cb) cb(result, null);\n          reject(result);\n        }\n      } else {\n        let error = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, `Invalid response from api ${url}`);\n        if (cb) cb(error);\n        reject(error);\n      }\n    }).catch(function (error) {\n      _logMessage(error);\n\n      cb(error, null);\n      reject(error);\n    });\n  });\n};\n\nconst getLoginTransactionReceipt = async (engine, txHash, userAddress) => {\n  var receipt = await web3.eth.getTransactionReceipt(txHash);\n\n  if (receipt) {\n    if (receipt.status) {\n      await _getUserContractWallet(engine, userAddress, (error, userContract) => {\n        if (!error && userContract) {\n          _setLocalData(userAddress, userContract);\n\n          engine.isLogin = true;\n          eventEmitter.emit(EVENTS.LOGIN_CONFIRMATION, \"User Contract wallet created Successfully\", userContract);\n        }\n      });\n    } else if (!receipt.status) {\n      eventEmitter.emit(EVENTS.BICONOMY_ERROR, formatMessage(RESPONSE_CODES.USER_CONTRACT_CREATION_FAILED, \"User Contract wallet creation Failed\"));\n    }\n\n    if (loginInterval) {\n      clearInterval(loginInterval);\n    }\n  }\n};\n\nBiconomy.prototype.isReady = function () {\n  return this.status === STATUS.BICONOMY_READY;\n};\n/**\n * Method used to login to biconomy. It takes user's public address as input\n * and if user contract wallet is not found for the user then it deploys\n * new user contract for the user. It user contract already exists it just\n * resolve to the contract wallet address.\n *\n * @returns Promise object that resolve to either transactionHash info or Contract wallet address\n **/\n\n\nBiconomy.prototype.login = async function (signer, cb) {\n  return new Promise(async (resolve, reject) => {\n    if (!signer || typeof signer != 'string') {\n      let response = formatMessage(RESPONSE_CODES.INVALID_DATA, \"signer parameter is mandatory and should be of type 'string'\");\n      if (cb) cb(response);\n      reject(response);\n      return;\n    }\n\n    let engine = this;\n    let message = {};\n    message.userAddress = signer.toLowerCase();\n    message.providerId = engine.providerId;\n    let nonce = await _getUserNonce(signer, this);\n\n    if (!nonce) {\n      nonce = 0;\n    }\n\n    message.nonce = nonce;\n    const dataToSign = JSON.stringify({\n      types: {\n        EIP712Domain: loginDomainType,\n        LoginMessage: loginMessageType\n      },\n      domain: loginDomainData,\n      primaryType: \"LoginMessage\",\n      message: message\n    });\n    console.debug(`Biconomy engine status ${engine.status}`);\n\n    if (engine.status != STATUS.BICONOMY_READY) {\n      return cb(formatMessage(RESPONSE_CODES.BICONOMY_NOT_INITIALIZED, 'Biconomy SDK is not initialized properly'));\n    }\n\n    web3.currentProvider.sendAsync({\n      jsonrpc: JSON_RPC_VERSION,\n      id: '101',\n      method: config.signTypedV3Method,\n      params: [signer, dataToSign]\n    }, function (error, signature) {\n      if (error) {\n        let response = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, error);\n        if (cb) cb(response);\n        reject(response);\n      } else {\n        let data = {};\n        data.signature = signature.result;\n        data.from = signer;\n        data.providerId = engine.providerId;\n        axios.post(`${baseURL}${userLoginPath}`, data).then(function (response) {\n          const data = response.data;\n          console.debug(data);\n          let result = {};\n\n          if (data.flag && data.flag == BICONOMY_RESPONSE_CODES.ACTION_COMPLETE) {\n            result.code = RESPONSE_CODES.SUCCESS_RESPONSE;\n\n            if (data.userContract) {\n              result.message = `User login successfull`;\n              result.userContract = data.userContract;\n              engine.isLogin = true;\n\n              _setLocalData(signer, data.userContract);\n            } else if (data.transactionHash) {\n              result.message = `User contract creation initiated`;\n              result.transactionHash = data.transactionHash;\n              loginInterval = setInterval(function () {\n                getLoginTransactionReceipt(engine, data.transactionHash, signer);\n              }, 2000);\n            }\n\n            if (cb) cb(null, result);\n            resolve(result);\n          } else {\n            result.code = RESPONSE_CODES.ERROR_RESPONSE;\n            result.message = data.log;\n            if (cb) cb(result, null);\n            reject(result);\n          }\n        }).catch(function (error) {\n          console.debug(error);\n          let response = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, error);\n          if (cb) cb(response);\n          reject(response);\n        });\n      }\n    });\n  });\n};\n/**\n * Function used to logout user from biconomy. It clears any internal user state and local storage.\n */\n\n\nBiconomy.prototype.logout = function () {\n  removeFromStorage(USER_ACCOUNT);\n  removeFromStorage(USER_CONTRACT);\n  this.isLogin = false;\n};\n/**\n * Function to return user contract wallet address.\n *\n * @param {string} userAddress User address for which contract wallet is requested\n * @returns A promise that resolves to user contact wallet if it exists else error response.\n */\n\n\nBiconomy.prototype.getUserContract = async function (userAddress) {\n  let response;\n\n  if (this.isLogin) {\n    let userAddressFromStorage = getFromStorage(USER_ACCOUNT);\n\n    if (userAddressFromStorage && userAddress) {\n      if (userAddressFromStorage.toLowerCase() === userAddress.toLowerCase()) {\n        response = formatMessage(RESPONSE_CODES.SUCCESS_RESPONSE, \"User Contract Wallet address fetched successfully\");\n        response.userContract = getFromStorage(USER_CONTRACT);\n      }\n\n      if (!response) {\n        let userContract = await _getUserContractWallet(this, userAddress);\n\n        if (userContract) {\n          response = formatMessage(RESPONSE_CODES.SUCCESS_RESPONSE, \"User Contract Wallet address fetched successfully\");\n          response.userContract = userContract;\n        } else {\n          response = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Unable to fetch User Contract Wallet\");\n        }\n      }\n    }\n  } else {\n    response = formatMessage(RESPONSE_CODES.USER_NOT_LOGGED_IN, \"Please login to biconomy first\");\n  }\n\n  return response;\n};\n\nBiconomy.prototype.getUserAccount = async function () {\n  return await _getUserAccount(this);\n};\n\nfunction formatMessage(code, message) {\n  return {\n    code: code,\n    message: message\n  };\n}\n/**\n * Setting data in localstorage to check later if user contract and user account\n * already exists and user has already logged in to biconomy once.\n **/\n\n\nfunction _setLocalData(signer, userContract) {\n  if (typeof localStorage != 'undefined') {\n    if (signer && userContract) {\n      localStorage.setItem(USER_ACCOUNT, signer);\n      localStorage.setItem(USER_CONTRACT, userContract);\n    }\n  } else {\n    this[USER_ACCOUNT] = signer;\n    this[USER_CONTRACT] = userContract;\n  }\n}\n\nfunction removeFromStorage(key) {\n  if (typeof localStorage != 'undefined') {\n    localStorage.removeItem(key);\n  } else {\n    this[key] = null;\n  }\n}\n\nfunction getFromStorage(key) {\n  if (typeof localStorage != 'undefined') {\n    return localStorage.getItem(key);\n  } else {\n    return this[key];\n  }\n}\n/**\n * Single method to be used for logging purpose.\n *\n * @param {string} message Message to be logged\n */\n\n\nfunction _logMessage(message) {\n  if (config && config.logsEnabled && console.log) {\n    console.log(message);\n  }\n}\n\nvar scientificToDecimal = function (num) {\n  var nsign = Math.sign(num); //remove the sign\n\n  num = Math.abs(num); //if the number is in scientific notation remove it\n\n  if (/\\d+\\.?\\d*e[\\+\\-]*\\d+/i.test(num)) {\n    var zero = '0',\n        parts = String(num).toLowerCase().split('e'),\n        //split into coeff and exponent\n    e = parts.pop(),\n        //store the exponential part\n    l = Math.abs(e),\n        //get the number of zeros\n    sign = e / l,\n        coeff_array = parts[0].split('.');\n\n    if (sign === -1) {\n      l = l - coeff_array[0].length;\n\n      if (l < 0) {\n        num = coeff_array[0].slice(0, l) + '.' + coeff_array[0].slice(l) + (coeff_array.length === 2 ? coeff_array[1] : '');\n      } else {\n        num = zero + '.' + new Array(l + 1).join(zero) + coeff_array.join('');\n      }\n    } else {\n      var dec = coeff_array[1];\n      if (dec) l = l - dec.length;\n\n      if (l < 0) {\n        num = coeff_array[0] + dec.slice(0, l) + '.' + dec.slice(l);\n      } else {\n        num = coeff_array.join('') + new Array(l + 1).join(zero);\n      }\n    }\n  }\n\n  return nsign < 0 ? '-' + num : num;\n};\n\nmodule.exports = Biconomy;","map":{"version":3,"sources":["/home/hayden/workplace/dapp-demo/node_modules/@biconomy/mexa/src/index.js"],"names":["axios","require","Promise","txDecoder","config","RESPONSE_CODES","EVENTS","BICONOMY_RESPONSE_CODES","STATUS","DEFAULT_PAYLOAD_ID","Web3","baseURL","userLoginPath","withdrawFundsUrl","getUserContractPath","JSON_RPC_VERSION","USER_ACCOUNT","USER_CONTRACT","NATIVE_META_TX_URL","nativeMetaTxUrl","decoderMap","smartContractMap","web3","events","eventEmitter","EventEmitter","loginInterval","domainType","metaInfoType","relayerPaymentType","metaTransactionType","domainData","name","eip712DomainName","version","eip712SigVersion","verifyingContract","eip712VerifyingContract","loginDomainType","loginMessageType","loginDomainData","Biconomy","provider","options","_validate","status","INIT","dappId","apiKey","isLogin","dappAPIMap","strictMode","providerId","readViaContract","READY","BICONOMY_READY","LOGIN_CONFIRMATION","ERROR","BICONOMY_ERROR","pendingLoginTransactions","debug","logsEnabled","_init","defaultAccount","eth","proto","Object","getPrototypeOf","keys","getOwnPropertyNames","i","length","key","providerSend","send","sendAsync","payload","cb","method","handleSendTransaction","error","result","response","_createJsonRpcResponse","sendSignedTransaction","userContract","getFromStorage","params","from","currentProvider","Error","prototype","getLoginMessageToSign","signer","engine","resolve","reject","formatMessage","INVALID_DATA","message","userAddress","toLowerCase","nonce","_getUserNonce","dataToSign","types","EIP712Domain","LoginMessage","domain","primaryType","getUserMessageToSign","rawTransaction","decodedTx","decodeTx","to","data","value","methodInfo","decodeMethod","DASHBOARD_DATA_MISMATCH","methodName","api","_logMessage","paramArray","push","_getParamValue","account","accounts","recoverTransaction","ERROR_RESPONSE","end","userContractWallet","_getUserContractWallet","USER_CONTRACT_NOT_FOUND","metaInfo","contractWallet","relayerPayment","token","DEFAULT_RELAYER_PAYMENT_TOKEN_ADDRESS","amount","DEFAULT_RELAYER_PAYMENT_AMOUNT","batchId","NONCE_BATCH_ID","_getUserContractNonce","parseInt","utils","toHex","txGas","gasLimit","toString","expiry","EXPIRY","baseGas","BASE_GAS","MetaInfo","RelayerPayment","MetaTransaction","BICONOMY_NOT_INITIALIZED","onEvent","type","callback","on","EVENT_NOT_SUPPORTED","id","jsonrpc","isHex","signature","API_NOT_FOUND","url","apiId","gasPrice","_sendTransaction","code","USER_NOT_LOGGED_IN","rawTx","nonceBatchId","INVALID_PAYLOAD","JSON","stringify","emit","withdrawFunds","receiverAddress","withdrawAmount","_getUserAccount","signTypedV3Method","defaults","headers","common","post","then","SUCCESS_RESPONSE","log","txHash","catch","flag","gas","console","info","USER_ACCOUNT_NOT_FOUND","contractABI","contract","Contract","parse","methods","apply","estimateGas","address","getNonceAPI","get","version2","SMART_CONTRACT_DATA_READY","getAPIInfoAPI","listApis","apiList","DAPP_API_DATA_READY","res","paramObj","match","input","scientificToDecimal","ACTION_COMPLETE","SUCCESS","getDappAPI","dappResponse","dapp","dappNetworkId","networkId","networkResponse","NETWORK_ID_NOT_FOUND","providerNetworkId","NETWORK_ID_MISMATCH","chainId","signatureTypesResult","systemInfo","relayHubAddress","getDAppInfoAPI","SMART_CONTRACT_NOT_FOUND","smartContractList","smartContracts","forEach","abiDecoder","addABI","abi","userLocalAccount","userLocalContract","undefined","toUpperCase","NO_DATA","DAPP_NOT_FOUND","promise","owner","accountLogin","_setLocalData","transactionHash","setInterval","getLoginTransactionReceipt","receipt","getTransactionReceipt","USER_CONTRACT_CREATION_FAILED","clearInterval","isReady","login","logout","removeFromStorage","getUserContract","userAddressFromStorage","getUserAccount","localStorage","setItem","removeItem","getItem","num","nsign","Math","sign","abs","test","zero","parts","String","split","e","pop","l","coeff_array","slice","Array","join","dec","module","exports"],"mappings":"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","sourcesContent":["const axios = require(\"axios\");\nconst Promise = require('promise');\nconst txDecoder = require('ethereum-tx-decoder');\nconst {config, RESPONSE_CODES, EVENTS, BICONOMY_RESPONSE_CODES, STATUS} = require('./config');\nconst DEFAULT_PAYLOAD_ID = \"99999999\";\nconst Web3 = require('web3');\nconst baseURL = config.baseURL;\nconst userLoginPath = config.userLoginPath;\nconst withdrawFundsUrl = config.withdrawFundsUrl;\nconst getUserContractPath = config.getUserContractPath;\nconst JSON_RPC_VERSION = config.JSON_RPC_VERSION;\nconst USER_ACCOUNT = config.USER_ACCOUNT;\nconst USER_CONTRACT = config.USER_CONTRACT;\nconst NATIVE_META_TX_URL = config.nativeMetaTxUrl;\n\nlet decoderMap = {}, smartContractMap = {};\nlet web3;\nconst events = require('events');\nvar eventEmitter = new events.EventEmitter();\nlet loginInterval;\n\nlet domainType, metaInfoType, relayerPaymentType, metaTransactionType;\n\nlet domainData = {\n    name: config.eip712DomainName,\n    version: config.eip712SigVersion,\n    verifyingContract: config.eip712VerifyingContract\n};\n\n// EIP712 format data for login\nlet loginDomainType, loginMessageType, loginDomainData;\n\nfunction Biconomy(provider, options) {\n\t_validate(options);\n\tthis.status = STATUS.INIT;\n\tthis.dappId = options.dappId;\n\tthis.apiKey = options.apiKey;\n\tthis.isLogin = false;\n\tthis.dappAPIMap = {};\n\tthis.strictMode = options.strictMode || false;\n\tthis.providerId = options.providerId || 0;\n\tthis.readViaContract = options.readViaContract || false;\n\tthis.READY = STATUS.BICONOMY_READY;\n\tthis.LOGIN_CONFIRMATION = EVENTS.LOGIN_CONFIRMATION;\n\tthis.ERROR = EVENTS.BICONOMY_ERROR;\n\tthis.pendingLoginTransactions = {};\n\tif(options.debug) {\n\t\tconfig.logsEnabled = true;\n\t}\n\t_init(this.dappId, this.apiKey, this);\n\n\tif(provider) {\n\t\tweb3 = new Web3(provider);\n\t\tif(options.defaultAccount) {\n\t\t\tweb3.eth.defaultAccount = options.defaultAccount;\n\t\t}\n\t\tconst proto = Object.getPrototypeOf(provider)\n\t\tconst keys = Object.getOwnPropertyNames(proto)\n\n\t\tfor(var i=0;i<keys.length;i++){\n\t\t\tthis[keys[i]] = provider[keys[i]];\n\t\t}\n\n\t\tfor(var key in provider) {\n\t\t\tif(!this[key]) {\n\t\t\t\tthis[key] = provider[key];\n\t\t\t}\n\t\t}\n\n\t\tthis.providerSend = provider.send || provider.sendAsync;\n\t\tthis.send = function(payload, cb) {\n\t\t\tif(payload.method == 'eth_sendTransaction') {\n\n\t\t\t\thandleSendTransaction(this, payload, (error, result) => {\n\t\t\t\t\tlet response = _createJsonRpcResponse(payload, error, result);\n\t\t\t\t\tif(cb)  {\n\t\t\t\t\t\tcb(error, response);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t} else if(payload.method == 'eth_sendRawTransaction') {\n\n\t\t\t\tsendSignedTransaction(this, payload, (error, result) => {\n\t\t\t\t\tlet response = _createJsonRpcResponse(payload, error, result);\n\t\t\t\t\tif(cb) {\n\t\t\t\t\t\tcb(error, response);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t} else if(payload.method == 'eth_call') {\n\t\t\t\tlet userContract = getFromStorage(USER_CONTRACT);\n\t\t\t\tif(this.readViaContract && this.isLogin && userContract) {\n\t\t\t\t\tif(payload && payload.params && payload.params[0]) {\n\t\t\t\t\t\tpayload.params[0].from = userContract;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tweb3.currentProvider.send(payload, cb);\n\t\t\t} else {\n\t\t\t\tweb3.currentProvider.send(payload, cb);\n\t\t\t}\n\t\t};\n\t\tthis.sendAsync = this.send;\n\t} else {\n\t\tthrow new Error('Please pass a provider to Biconomy.');\n\t}\n}\n\n/**\n * This method returns an EIP712 formatted data ready to be signed\n * that will be used in login method/API.\n * LoginMessageType [\n * \t { name: \"userAddress\", type: \"address\"},\n *   { name: \"nonce\", type: \"uint256\"},\n *   { name: \"providerId\", type: \"string\"}\n * ]\n */\nBiconomy.prototype.getLoginMessageToSign = function(signer) {\n\tlet engine = this;\n\treturn new Promise(async (resolve, reject) => {\n\t\ttry {\n\t\t\tif(!signer || typeof signer != 'string') {\n\t\t\t\tlet response = formatMessage(RESPONSE_CODES.INVALID_DATA, \"signer parameter is mandatory and should be of type 'string'\");\n\t\t\t\treturn reject(response);\n\t\t\t}\n\t\t\tlet message = {};\n\t\t\tmessage.userAddress = signer.toLowerCase();\n\t\t\tmessage.providerId = engine.providerId\n\t\t\tlet nonce = await _getUserNonce(signer, this);\n\t\t\tif(!nonce) {\n\t\t\t\tnonce = 0;\n\t\t\t}\n\t\t\tmessage.nonce = nonce;\n\n\t\t\tconst dataToSign = {\n\t\t\t\ttypes: {\n\t\t\t\t\tEIP712Domain: loginDomainType,\n\t\t\t\t\tLoginMessage: loginMessageType\n\t\t\t\t},\n\t\t\t\tdomain: loginDomainData,\n\t\t\t\tprimaryType: \"LoginMessage\",\n\t\t\t\tmessage: message\n\t\t\t};\n\t\t\tresolve(dataToSign);\n\t\t} catch(error) {\n\t\t\treject(error);\n\t\t}\n\t});\n}\n\n/**\n * This method returns an EIP712 formatted data ready to be signed\n * that will be used while sending the transaction using web3.eth.sendSignedTransaction\n * Returned data structure types\n * RelayerPaymentType [\n *   { name: \"token\", type: \"address\"},\n *   { name: \"amount\", type: \"uint256\"}\n * ]\n\n * MetaTransactionType = [\n *\t{ name: \"from\", type: \"address\"},\n *\t{ name: \"to\", type: \"address\"},\n *\t{ name: \"data\", type: \"bytes\"},\n *\t{ name: \"batchId\", type: \"uint256\"},\n *\t{ name: \"nonce\", type: \"uint256\"},\n *\t{ name: \"expiry\", type: \"uint256\"},\n *\t{ name: \"txGas\", type: \"uint256\"},\n *\t{ name: \"baseGas\", type: \"uint256\"},\n *\t{ name: \"value\", type: \"uint256\"},\n *  { name: \"metaInfo\", type: \"MetaInfo\"},\n *  { name: \"relayerPayment\", type: \"RelayerPayment\"}\n * ]\n */\nBiconomy.prototype.getUserMessageToSign = function(rawTransaction, cb) {\n\tlet engine = this;\n\treturn new Promise(async (resolve, reject)=>{\n\n\t\tif(rawTransaction) {\n\t\t\tlet decodedTx = txDecoder.decodeTx(rawTransaction);\n\t\t\tif(decodedTx.to && decodedTx.data && decodedTx.value) {\n\t\t\t\tconst methodInfo = decodeMethod(decodedTx.to.toLowerCase(), decodedTx.data);\n\t\t\t\tif(!methodInfo) {\n\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.DASHBOARD_DATA_MISMATCH,\n\t\t\t\t\t\t`Smart Contract address registered on dashboard is different than what is sent(${decodedTx.to}) in current transaction`);\n\t\t\t\t\tif(cb) cb(error);\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\t\t\t\tlet methodName = methodInfo.name;\n\t\t\t\tlet api = engine.dappAPIMap[methodName];\n\t\t\t\tif(!api) {\n\t\t\t\t\t_logMessage(`API not found for method ${methodName}`);\n\n\t\t\t\t}\n\t\t\t\t_logMessage('API found');\n\t\t\t\tlet params = methodInfo.params;\n\t\t\t\tlet paramArray = [];\n\t\t\t\tfor(let i = 0; i < params.length; i++) {\n\t\t\t\t\tparamArray.push(_getParamValue(params[i]));\n\t\t\t\t}\n\n\t\t\t\tlet account = web3.eth.accounts.recoverTransaction(rawTransaction);\n\t\t\t\t_logMessage(`signer is ${account}`);\n\t\t\t\tif(!account) {\n\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.ERROR_RESPONSE ,`Not able to get user account from signed transaction`);\n\t\t\t\t\treturn end(error);\n\t\t\t\t}\n\n\t\t\t\tlet userContractWallet = await _getUserContractWallet(engine, account);\n\t\t\t\t_logMessage(`User contract wallet ${userContractWallet}`);\n\n\t\t\t\tif(!userContractWallet) {\n\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.USER_CONTRACT_NOT_FOUND ,`User contract wallet not found`);\n\t\t\t\t\tif(cb) cb(error);\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\tlet metaInfo = {};\n\t\t\t\tmetaInfo.contractWallet =  userContractWallet;\n\n\t\t\t\tlet relayerPayment = {};\n\t\t\t\trelayerPayment.token = config.DEFAULT_RELAYER_PAYMENT_TOKEN_ADDRESS;\n\t\t\t\trelayerPayment.amount = config.DEFAULT_RELAYER_PAYMENT_AMOUNT;\n\n\t\t\t\tlet message = {};\n\t\t\t\tmessage.from = account;\n\t\t\t\tmessage.to = decodedTx.to.toLowerCase();\n\t\t\t\tmessage.data = decodedTx.data;\n\t\t\t\tmessage.batchId = config.NONCE_BATCH_ID;\n\t\t\t\tlet nonce = await _getUserContractNonce(account,engine);\n\t\t\t\tmessage.nonce = parseInt(nonce);\n\t\t\t\tmessage.value = web3.utils.toHex(decodedTx.value);\n\t\t\t\tmessage.txGas = decodedTx.gasLimit.toString()?decodedTx.gasLimit.toString():0;\n\t\t\t\tmessage.expiry = config.EXPIRY;\n\t\t\t\tmessage.baseGas = config.BASE_GAS;\n\t\t\t\tmessage.metaInfo = metaInfo;\n\t\t\t\tmessage.relayerPayment = relayerPayment;\n\n\t\t\t\tconst dataToSign = {\n\t\t\t\t\ttypes: {\n\t\t\t\t\t\tEIP712Domain: domainType,\n\t\t\t\t\t\tMetaInfo: metaInfoType,\n\t\t\t\t\t\tRelayerPayment: relayerPaymentType,\n\t\t\t\t\t\tMetaTransaction: metaTransactionType\n\t\t\t\t\t},\n\t\t\t\t\tdomain: domainData,\n\t\t\t\t\tprimaryType: \"MetaTransaction\",\n\t\t\t\t\tmessage: message\n\t\t\t\t};\n\t\t\t\tif(cb) cb(null, dataToSign);\n\t\t\t\treturn resolve(dataToSign);\n\t\t\t} else {\n\t\t\t\tlet error = formatMessage(RESPONSE_CODES.BICONOMY_NOT_INITIALIZED ,\n\t\t\t\t\t`Decoders not initialized properly in mexa sdk. Make sure your have smart contracts registered on Mexa Dashboard`);\n\t\t\t\tif(cb) cb(error);\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t}\n\t});\n}\n\n/**\n * Method used to listen to events emitted from the SDK\n */\nBiconomy.prototype.onEvent = function(type, callback) {\n\tif(type == this.READY || type == this.ERROR || type == this.LOGIN_CONFIRMATION) {\n\t\teventEmitter.on(type, callback);\n\t\treturn this;\n\t} else {\n\t\tthrow formatMessage(RESPONSE_CODES.EVENT_NOT_SUPPORTED, `${type} event is not supported.`);\n\t}\n}\n\n/**\n * Create a JSON RPC response from the given error and result parameter.\n **/\nfunction _createJsonRpcResponse(payload, error, result) {\n\tlet response = {};\n\tresponse.id = payload.id;\n\tresponse.jsonrpc = JSON_RPC_VERSION;\n\tif(error) {\n\t\tresponse.error = error;\n\t} else if(result.error) {\n\t\tresponse.error = result.error;\n\t} else if(web3.utils.isHex(result)) {\n\t\tresponse.result = result;\n\t} else {\n\t\tresponse = result;\n\t}\n\treturn response;\n}\n\nfunction decodeMethod(to, data) {\n\tif(to && data && decoderMap[to]) {\n\t\treturn decoderMap[to].decodeMethod(data);\n\t}\n\treturn;\n}\n\n/**\n * Method used to handle transaction initiated using web3.eth.sendSignedTransaction method\n * It extracts rawTransaction from payload and decode it to get required information like from, to,\n * data, gasLimit to create the payload for biconomy meta transaction API.\n * In case of Native meta transaction, payload just contains rawTransaction\n * In case of contract based meta transaction, payload contains rawTransaction and signature wrapped\n * in a json object.\n *\n * @param {Object} engine Reference to this SDK instance\n * @param {Object} payload Payload data\n * @param {Function} end Callback function with error as first argument\n */\nasync function sendSignedTransaction(engine, payload, end) {\n\n\tif(payload && payload.params[0]) {\n\t\tlet data = payload.params[0];\n\t\tlet rawTransaction, signature;\n\n\t\tif(typeof data == \"string\") {\n\t\t\t// Here user send the rawTransaction in the payload directly. Probably the case of native meta transaction\n\t\t\trawTransaction = data;\n\t\t} else if(typeof data == \"object\") {\n\t\t\t// Here user wrapped raw Transaction in json object along with signature\n\t\t\tsignature = data.signature;\n\t\t\trawTransaction = data.rawTransaction;\n\t\t}\n\n\t\tif(rawTransaction) {\n\t\t\tlet decodedTx = txDecoder.decodeTx(rawTransaction);\n\n\t\t\tif(decodedTx.to && decodedTx.data && decodedTx.value) {\n\t\t\t\tconst methodInfo = decodeMethod(decodedTx.to.toLowerCase(), decodedTx.data);\n\t\t\t\tif(!methodInfo) {\n\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.DASHBOARD_DATA_MISMATCH,\n\t\t\t\t\t\t`Smart Contract address registered on dashboard is different than what is sent(${decodedTx.to}) in current transaction`);\n\t\t\t\t\treturn end(error);\n\t\t\t\t}\n\t\t\t\tlet methodName = methodInfo.name;\n\t\t\t\tlet api = engine.dappAPIMap[methodName];\n\t\t\t\tif(!api) {\n\t\t\t\t\t_logMessage(`API not found for method ${methodName}`);\n\t\t\t\t\t_logMessage(`Strict mode ${engine.strictMode}`);\n\t\t\t\t\tif(engine.strictMode) {\n\t\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.API_NOT_FOUND,\n\t\t\t\t\t\t\t`Biconomy strict mode is on. No registered API found for method ${methodName}. Please register API from developer dashboard.`);\n\t\t\t\t\t\treturn end(error, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_logMessage(`Falling back to default provider as strict mode is false in biconomy`);\n\t\t\t\t\t\treturn engine.providerSend(rawTransaction, end);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_logMessage('API found');\n\t\t\t\tlet params = methodInfo.params;\n\t\t\t\tlet paramArray = [];\n\t\t\t\tfor(let i = 0; i < params.length; i++) {\n\t\t\t\t\tparamArray.push(_getParamValue(params[i]));\n\t\t\t\t}\n\n\t\t\t\tlet account = web3.eth.accounts.recoverTransaction(rawTransaction);\n\t\t\t\t_logMessage(`signer is ${account}`);\n\t\t\t\tif(!account) {\n\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.ERROR_RESPONSE ,`Not able to get user account from signed transaction`);\n\t\t\t\t\treturn end(error);\n\t\t\t\t}\n\t\t\t\tif(api.url == NATIVE_META_TX_URL) {\n\t\t\t\t\tlet data = {};\n\t\t\t\t\tdata.userAddress = account;\n\t\t\t\t\tdata.apiId = api.id;\n\t\t\t\t\tdata.params = paramArray;\n\t\t\t\t\tdata.gasLimit = decodedTx.gasLimit.toString();\n\t\t\t\t\tdata.gasPrice = decodedTx.gasPrice.toString();\n\t\t\t\t\t_sendTransaction(engine, account, api, data, end);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(!engine.isLogin){\n\t\t\t\t\t\tlet error = {};\n\t\t\t\t\t\terror.message = 'User not logged in to biconomy';\n\t\t\t\t\t\terror.code = RESPONSE_CODES.USER_NOT_LOGGED_IN;\n\t\t\t\t\t\treturn end(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(signature ) {\n\n\t\t\t\t\t\t\tlet relayerPayment = {};\n\t\t\t\t\t\t\trelayerPayment.token = config.DEFAULT_RELAYER_PAYMENT_TOKEN_ADDRESS;\n\t\t\t\t\t\t\trelayerPayment.amount = config.DEFAULT_RELAYER_PAYMENT_AMOUNT;\n\n\t\t\t\t\t\t\tlet data = {};\n\t\t\t\t\t\t\tdata.rawTx = rawTransaction;\n\t\t\t\t\t\t\tdata.signature = signature;\n\t\t\t\t\t\t\tdata.to = decodedTx.to.toLowerCase();\n\t\t\t\t\t\t\tdata.from = account;\n\t\t\t\t\t\t\tdata.apiId = api.id;\n\t\t\t\t\t\t\tdata.data = decodedTx.data;\n\t\t\t\t\t\t\tdata.value = web3.utils.toHex(decodedTx.value)\n\t\t\t\t\t\t\tdata.gasLimit = decodedTx.gasLimit.toString();\n\t\t\t\t\t\t\tdata.gasPrice = decodedTx.gasPrice.toString();\n\t\t\t\t\t\t\tdata.nonceBatchId = config.NONCE_BATCH_ID;\n\t\t\t\t\t\t\tdata.expiry = config.EXPIRY;\n\t\t\t\t\t\t\tdata.baseGas = config.BASE_GAS;\n\t\t\t\t\t\t\tdata.relayerPayment = {\n\t\t\t\t\t\t\t\ttoken: relayerPayment.token,\n\t\t\t\t\t\t\t\tamount: relayerPayment.amount\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t_sendTransaction(engine, account, api, data, end);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.INVALID_PAYLOAD ,\n\t\t\t\t\t\t\t\t`Invalid payload data ${JSON.stringify(payload.params[0])}. message and signature are required in param object`);\n\t\t\t\t\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n\t\t\t\t\t\t\tend(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet error = formatMessage(RESPONSE_CODES.BICONOMY_NOT_INITIALIZED ,\n\t\t\t\t\t`Decoders not initialized properly in mexa sdk. Make sure your have smart contracts registered on Mexa Dashboard`);\n\t\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n\t\t\t\tend(error);\n\t\t\t}\n\t\t} else {\n\t\t\tlet error = formatMessage(RESPONSE_CODES.INVALID_PAYLOAD ,\n\t\t\t\t`Invalid payload data ${JSON.stringify(payload.params[0])}.rawTransaction is required in param object`);\n\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n\t\t\tend(error);\n\t\t}\n\t} else {\n\t\tlet error = formatMessage(RESPONSE_CODES.INVALID_PAYLOAD ,\n\t\t\t`Invalid payload data ${JSON.stringify(payload.params[0])}. Non empty Array expected in params key`);\n\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n\t\tend(error);\n\t}\n}\n\n/**\n * Method to withdraw ether from use contract wallets.\n * It takes the receiverAddress and withdraw amount in wei.\n * An optional callback parameter can also be given that has first parameter as error and\n * second parameter as result containing withdraw transaction hash.\n *\n * Returns a promise that resolves to result object containing withdraw transaction hash.\n */\nBiconomy.prototype.withdrawFunds = function(receiverAddress, withdrawAmount, cb) {\n\tlet engine = this;\n\treturn new Promise(async (resolve, reject)=>{\n\t\tlet account = await _getUserAccount(this);\n\t\tlet nonce = await _getUserContractNonce(account,this);\n\t\tlet userContractWallet = await _getUserContractWallet(engine, account);\n\t\tif(!userContractWallet) {\n\t\t\tlet error = formatMessage(RESPONSE_CODES.USER_CONTRACT_NOT_FOUND ,`User contract wallet not found`);\n\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n\t\t\tif(cb) cb(error);\n\t\t\treturn reject(error);\n\t\t}\n\t\tlet metaInfo = {};\n\t\tmetaInfo.contractWallet =  userContractWallet;\n\n\t\tlet relayerPayment = {};\n\t\trelayerPayment.token = config.DEFAULT_RELAYER_PAYMENT_TOKEN_ADDRESS;\n\t\trelayerPayment.amount = config.DEFAULT_RELAYER_PAYMENT_AMOUNT;\n\n\t\tlet message = {};\n\t\tmessage.from = account;\n\t\tmessage.to = receiverAddress;\n\t\tmessage.data = \"0x0\";\n\t\tmessage.batchId = config.NONCE_BATCH_ID;\n\t\tmessage.nonce = parseInt(nonce);\n\t\tmessage.value = web3.utils.toHex(withdrawAmount || 0);\n\t\tmessage.txGas = 0;\n\t\tmessage.expiry = config.EXPIRY;\n\t\tmessage.baseGas = config.BASE_GAS;\n\t\tmessage.metaInfo = metaInfo;\n\t\tmessage.relayerPayment = relayerPayment;\n\t\tconst dataToSign = JSON.stringify({\n\t\t\ttypes: {\n\t\t\t\tEIP712Domain: domainType,\n\t\t\t\tMetaInfo: metaInfoType,\n\t\t\t\tRelayerPayment: relayerPaymentType,\n\t\t\t\tMetaTransaction: metaTransactionType\n\t\t\t},\n\t\t\tdomain: domainData,\n\t\t\tprimaryType: \"MetaTransaction\",\n\t\t\tmessage: message\n\t\t});\n\n\t\ttry{\n\t\t\tweb3.currentProvider.send({\n\t\t\t\tjsonrpc: JSON_RPC_VERSION,\n\t\t\t\tid: DEFAULT_PAYLOAD_ID,\n\t\t\t\tmethod: config.signTypedV3Method,\n\t\t\t\tparams: [account, dataToSign]\n\t\t\t}, function(error, response) {\n\t\t\t\t_logMessage(`User signature for payload id ${DEFAULT_PAYLOAD_ID} is ${response.result}`);\n\t\t\t\tif(error) {\n\t\t\t\t\tif(cb){\n\t\t\t\t\t\tcb(error);\n\t\t\t\t\t}\n\t\t\t\t\treject(error);\n\t\t\t\t} else if(response && response.error) {\n\t\t\t\t\tif(cb) cb(response.error);\n\t\t\t\t\treject(response.error);\n\t\t\t\t} else if(response && response.result) {\n\t\t\t\t\tlet data = {};\n\t\t\t\t\tdata.signature = response.result;\n\t\t\t\t\tdata.to = receiverAddress;\n\t\t\t\t\tdata.value = web3.utils.toHex(withdrawAmount) || 0;\n\t\t\t\t\tdata.from = account;\n\t\t\t\t\tdata.data = \"0x0\";\n\t\t\t\t\tdata.expiry = config.EXPIRY;\n\t\t\t\t\tdata.baseGas = config.BASE_GAS;\n\t\t\t\t\tdata.gasLimit = 0;\n\t\t\t\t\tdata.nonceBatchId = config.NONCE_BATCH_ID;\n\t\t\t\t\tdata.relayerPayment = relayerPayment;\n\n\t\t\t\t\taxios.defaults.headers.common[\"x-api-key\"] = engine.apiKey;\n\t\t\t\t\taxios.post(`${baseURL}${withdrawFundsUrl}`, data)\n\t\t\t\t\t.then(function(response) {\n\t\t\t\t\t\tif(response && response.data) {\n\t\t\t\t\t\t\tif(cb) cb(null, response.data);\n\t\t\t\t\t\t\tlet result = formatMessage(RESPONSE_CODES.SUCCESS_RESPONSE,response.data.log);\n\t\t\t\t\t\t\tresult.txHash = response.data.txHash;\n\t\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, `Unable to get response for api ${withdrawFundsUrl}`);\n\t\t\t\t\t\t\tif(cb) cb(error);\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.catch(function(error) {\n\t\t\t\t\t\tif(cb) cb(formatMessage(error.flag,error.log));\n\t\t\t\t\t\treject(formatMessage(error.flag,error.log));\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t} catch(error) {\n\t\t\tif(cb) cb(error);\n\t\t\treject(error);\n\t\t}\n\t});\n}\n/**\n * Function decodes the parameter in payload and gets the user signature using eth_signTypedData_v3\n * method and send the request to biconomy for processing and call the callback method 'end'\n * with transaction hash.\n *\n * This is an internal function that is called while intercepting eth_sendTransaction RPC method call.\n **/\nasync function handleSendTransaction(engine, payload, end) {\n\t_logMessage('Handle transaction with payload');\n\t_logMessage(payload);\n\tif(payload.params && payload.params[0] && payload.params[0].to) {\n\t\tif(decoderMap[payload.params[0].to.toLowerCase()]) {\n\t\t\tconst methodInfo = decodeMethod(payload.params[0].to.toLowerCase(), payload.params[0].data);\n\t\t\tlet methodName = methodInfo.name;\n\t\t\tlet api = engine.dappAPIMap[methodName];\n\t\t\tlet gasPrice = payload.params[0].gasPrice;\n\t\t\tlet gasLimit = payload.params[0].gas;\n\t\t\t_logMessage(api);\n\n\t\t\tif(!api) {\n\t\t\t\t_logMessage(`API not found for method ${methodName}`);\n\t\t\t\t_logMessage(`Strict mode ${engine.strictMode}`);\n\t\t\t\tif(engine.strictMode) {\n\t\t\t\t\tlet error = {};\n\t\t\t\t\terror.code = RESPONSE_CODES.API_NOT_FOUND;\n\t\t\t\t\terror.message = `Biconomy strict mode is on. No registered API found for method ${methodName}. Please register API from developer dashboard.`;\n\t\t\t\t\treturn end(error, null);\n\t\t\t\t} else {\n\t\t\t\t\t_logMessage(`Falling back to default provider as strict mode is false in biconomy`);\n\t\t\t\t\treturn engine.providerSend(payload, end);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsole.info('API found');\n\t\t\tlet params = methodInfo.params;\n\t\t\tlet paramArray = [];\n\t\t\tfor(let i = 0; i < params.length; i++) {\n\t\t\t\tparamArray.push(_getParamValue(params[i]));\n\t\t\t}\n\n\t\t\tconsole.info(\"Getting user account\");\n\t\t\tlet account = await _getUserAccount(engine, payload);\n\t\t\tif(!account) {\n\t\t\t\treturn end(`Not able to get user account`);\n\t\t\t}\n\t\t\tconsole.info(`User account fetched`);\n\t\t\tif(api.url == NATIVE_META_TX_URL) {\n\t\t\t\tlet data = {};\n\t\t\t\tdata.userAddress = account;\n\t\t\t\tdata.apiId = api.id;\n\t\t\t\tdata.params = paramArray;\n\t\t\t\tdata.gasPrice = gasPrice;\n\t\t\t\tdata.gasLimit = gasLimit;\n\t\t\t\t_sendTransaction(engine, account, api, data, end);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(engine.isLogin) {\n\t\t\t\t\tlet nonce = await _getUserContractNonce(account, engine);\n\t\t\t\t\tif(!nonce) {\n\t\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.USER_ACCOUNT_NOT_FOUND ,`User is not a registered biconomy user`);\n\t\t\t\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n\t\t\t\t\t\tend(error);\n\t\t\t\t\t}\n\t\t\t\t\tlet userContractWallet = await _getUserContractWallet(engine, account);\n\n\t\t\t\t\tif(!userContractWallet) {\n\t\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.USER_CONTRACT_NOT_FOUND ,`User contract wallet not found`);\n\t\t\t\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n\t\t\t\t\t\treturn end(error);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if gas limit is present, it not calculate gas limit\n\t\t\t\t\tif(!gasLimit || parseInt(gasLimit) == 0) {\n\t\t\t\t\t\tlet contractABI = smartContractMap[payload.params[0].to.toLowerCase()];\n\t\t\t\t\t\tif(contractABI) {\n\t\t\t\t\t\t\tlet contract = new web3.eth.Contract(JSON.parse(contractABI), payload.params[0].to.toLowerCase());\n\t\t\t\t\t\t\tgasLimit = await contract.methods[methodName].apply(null, paramArray).estimateGas({from: userContractWallet});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet metaInfo = {};\n\t\t\t\t\tmetaInfo.contractWallet =  userContractWallet;\n\n\t\t\t\t\tlet relayerPayment = {};\n\t\t\t\t\trelayerPayment.token = config.DEFAULT_RELAYER_PAYMENT_TOKEN_ADDRESS;\n\t\t\t\t\trelayerPayment.amount = config.DEFAULT_RELAYER_PAYMENT_AMOUNT;\n\n\t\t\t\t\tlet message = {};\n\t\t\t\t\tmessage.from = account;\n\t\t\t\t\tmessage.to = payload.params[0].to.toLowerCase();\n\t\t\t\t\tmessage.data = payload.params[0].data;\n\t\t\t\t\tmessage.batchId = config.NONCE_BATCH_ID;\n\t\t\t\t\tmessage.nonce = parseInt(nonce);\n\t\t\t\t\tmessage.value = web3.utils.toHex(payload.params[0].value || 0);\n\t\t\t\t\tmessage.txGas = gasLimit?gasLimit:0;\n\t\t\t\t\tmessage.expiry = config.EXPIRY;\n\t\t\t\t\tmessage.baseGas = config.BASE_GAS;\n\t\t\t\t\tmessage.metaInfo = metaInfo;\n\t\t\t\t\tmessage.relayerPayment = relayerPayment;\n\n\t\t\t\t\tconst dataToSign = JSON.stringify({\n\t\t\t\t\t\ttypes: {\n\t\t\t\t\t\t\tEIP712Domain: domainType,\n\t\t\t\t\t\t\tMetaInfo: metaInfoType,\n\t\t\t\t\t\t\tRelayerPayment: relayerPaymentType,\n\t\t\t\t\t\t\tMetaTransaction: metaTransactionType\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdomain: domainData,\n\t\t\t\t\t\tprimaryType: \"MetaTransaction\",\n\t\t\t\t\t\tmessage: message\n\t\t\t\t\t});\n\t\t\t\t\tconsole.debug(dataToSign);\n\t\t\t\t\tengine.send({\n\t\t\t\t\t\tjsonrpc: JSON_RPC_VERSION,\n\t\t\t\t\t\tid: payload.id,\n\t\t\t\t\t\tmethod: config.signTypedV3Method,\n\t\t\t\t\t\tparams: [account, dataToSign]\n\t\t\t\t\t}, function(error, response) {\n\t\t\t\t\t\tconsole.info(`User signature for payload id ${payload.id} is ${response.result}`);\n\t\t\t\t\t\tif(error) {\n\t\t\t\t\t\t\tend(error);\n\t\t\t\t\t\t} else if(response && response.error) {\n\t\t\t\t\t\t\tend(response.error);\n\t\t\t\t\t\t} else if(response && response.result) {\n\t\t\t\t\t\t\tlet data = {};\n\t\t\t\t\t\t\tdata.signature = response.result;\n\t\t\t\t\t\t\tdata.from = account;\n\t\t\t\t\t\t\tdata.to = payload.params[0].to.toLowerCase();\n\t\t\t\t\t\t\tdata.apiId = api.id;\n\t\t\t\t\t\t\tdata.dappId = engine.dappId;\n\n\t\t\t\t\t\t\tdata.data = payload.params[0].data;\n\t\t\t\t\t\t\tdata.nonceBatchId = config.NONCE_BATCH_ID;\n\t\t\t\t\t\t\tdata.expiry = config.EXPIRY;\n\t\t\t\t\t\t\tdata.baseGas = config.BASE_GAS;\n\t\t\t\t\t\t\tdata.userContract = userContractWallet;\n\t\t\t\t\t\t\tdata.value = web3.utils.toHex(payload.params[0].value || 0);\n\t\t\t\t\t\t\tdata.gasPrice = gasPrice;\n\t\t\t\t\t\t\tdata.gasLimit = gasLimit?gasLimit:0;\n\t\t\t\t\t\t\tdata.relayerPayment = {\n\t\t\t\t\t\t\t\ttoken: relayerPayment.token,\n\t\t\t\t\t\t\t\tamount: relayerPayment.amount\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t_sendTransaction(engine, account, api, data, end);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tend();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tlet error = {};\n\t\t\t\t\terror.message = 'User not logged in to biconomy';\n\t\t\t\t\terror.code = RESPONSE_CODES.USER_NOT_LOGGED_IN;\n\t\t\t\t\treturn end(error);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlet error = formatMessage(RESPONSE_CODES.BICONOMY_NOT_INITIALIZED ,\n\t\t\t\t`Decoders not initialized properly in mexa sdk. Make sure your have smart contracts registered on Mexa Dashboard`);\n\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n\t\t\tend(error);\n\t\t}\n\t} else {\n\t\tlet error = formatMessage(RESPONSE_CODES.INVALID_PAYLOAD ,\n\t\t\t`Invalid payload data ${JSON.stringify(payload)}. Expecting params key to be an array with first element having a 'to' property`);\n\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR, error);\n\t\tend(error);\n\t}\n}\n\n/**\n * It fetches the user nonce used during login.\n *\n * @param {string} address User address whole nonce is requested\n * @param {object} engine Reference to Mexa object.\n */\nasync function _getUserNonce(address, engine) {\n\ttry {\n\t\tlet getNonceAPI = `${baseURL}/api/${config.version}/dapp-user/getNonce?signer=${address}`;\n\t\taxios.defaults.headers.common[\"x-api-key\"] = engine.apiKey;\n\t\tlet response = await axios.get(getNonceAPI);\n\t\tif(response && response.status == 200 && response.data) {\n\t\t\treturn response.data.nonce;\n\t\t}\n\t\treturn;\n\t} catch(error) {\n\t\tif(error.response.status == 404) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn;\n\t}\n}\n\n/**\n * It query biconomy server for user contract nonce.\n *\n * @param {string} address user address whole nonce is requested\n * @param {object} engine Reference to mexa object\n */\nasync function _getUserContractNonce(address, engine) {\n\ttry {\n\t\tlet getNonceAPI = `${baseURL}/api/${config.version2}/dapp-user/getContractNonce?signer=${address}`;\n\t\taxios.defaults.headers.common[\"x-api-key\"] = engine.apiKey;\n\t\tlet response = await axios.get(getNonceAPI);\n\t\tif(response && response.status == 200 && response.data) {\n\t\t\treturn response.data.nonce;\n\t\t}\n\t\treturn;\n\t} catch(error) {\n\t\t_logMessage(error);\n\t\treturn;\n\t}\n}\n\n\n// On getting smart contract data get the API data also\neventEmitter.on(EVENTS.SMART_CONTRACT_DATA_READY, (dappId, engine)=>{\n\t// Get DApp API information from Database\n    let getAPIInfoAPI = `${baseURL}/api/${config.version}/meta-api?dappId=${dappId}`;\n\taxios.get(getAPIInfoAPI).then(function(response) {\n\t\tif(response && response.data && response.data.listApis) {\n\t\t\tlet apiList = response.data.listApis;\n\t\t\tfor(let i=0;i<apiList.length;i++) {\n\t\t\t\tengine.dappAPIMap[apiList[i].method] = apiList[i];\n\t\t\t}\n\t\t\teventEmitter.emit(EVENTS.DAPP_API_DATA_READY, engine);\n\t\t}\n\t}).catch(function(error) {\n      console.error(error);\n    });\n});\n\neventEmitter.on(EVENTS.DAPP_API_DATA_READY, (engine)=>{\n\tengine.status = STATUS.BICONOMY_READY;\n\teventEmitter.emit(STATUS.BICONOMY_READY);\n});\n\n/**\n * Get user account from current provider using eth_accounts method.\n **/\nfunction _getUserAccount(engine, payload, cb) {\n\tif(engine) {\n\t\tlet id = DEFAULT_PAYLOAD_ID;\n\t\tif(payload) {\n\t\t\tid = payload.id;\n\t\t}\n\t\tif(cb) {\n\t\t\tweb3.currentProvider.send({jsonrpc: JSON_RPC_VERSION, id: id, method: 'eth_accounts', params: []}, (error, response)=>{\n\t\t\t\tif(response && response.result && response.result.length == 0\n\t\t\t\t\t&& web3.eth.defaultAccount && web3.eth.defaultAccount != \"\") {\n\t\t\t\t\tresponse.result.push(web3.eth.defaultAccount);\n\t\t\t\t\tcb(error, response);\n\t\t\t\t} else {\n\t\t\t\t\tcb(error, response);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\treturn new Promise(function(resolve, reject) {\n\t\t\t\tweb3.currentProvider.send({jsonrpc: JSON_RPC_VERSION, id: id, method: 'eth_accounts', params: []}, function(error, res){\n\t\t\t\t\tif(error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else if(!res.result) {\n\t\t\t\t\t\treject(`Invalid response ${res}`);\n\t\t\t\t\t} else if(res.result && res.result.length == 0\n\t\t\t\t\t\t&& web3.eth.defaultAccount && web3.eth.defaultAccount != \"\") {\n\t\t\t\t\t\tresolve(web3.eth.defaultAccount);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(res.result[0]);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n}\n\n/**\n * Validate parameters passed to biconomy object. Dapp id and api key are mandatory.\n **/\nfunction _validate(options) {\n\tif(!options) {\n\t\tthrow new Error(`Options object needs to be passed to Biconomy Object with dappId and apiKey mandatory keys`);\n\t}\n\tif(!options.dappId || !options.apiKey) {\n\t\tthrow new Error(`dappId and apiKey are required in options object when creating Biconomy object`);\n\t}\n}\n\n/**\n * Get paramter value from param object based on its type.\n **/\nfunction _getParamValue(paramObj) {\n\tlet value;\n\tif(paramObj) {\n\t\tlet type = paramObj.type;\n\t\tswitch (type) {\n\t\t\tcase (type.match(/^uint/) || type.match(/^int/) || {}).input:\n\t\t\t\tvalue = scientificToDecimal(parseInt(paramObj.value));\n\t\t\t\tvalue = web3.utils.toHex(value);\n\t\t\t\tbreak;\n\t\t\tcase 'string':\n\t\t\t\tif(typeof paramObj.value === \"object\"){\n\t\t\t\t\tvalue = paramObj.value.toString();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = paramObj.value;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tvalue = paramObj.value;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn value;\n}\n\n/**\n * Method to send the transaction to biconomy server and call the callback method\n * to pass the result of meta transaction to web3 function call.\n * @param engine Object representing biconomy provider engine\n * @param account User selected account on current wallet\n * @param api API object got from biconomy server\n * @param data Data to be sent to biconomy server having transaction data\n * @param cb Callback method to be called to pass result or send error\n **/\nfunction _sendTransaction(engine, account, api, data, cb) {\n\tif(engine && account && api && data) {\n\t\tlet url = api.url;\n\t\taxios\n\t      .post(`${baseURL}${url}`, data)\n\t      .then(function(response) {\n\t\t\tif(response && response.data) {\n\t\t\t\tconst result = response.data;\n\t\t\t\t_logMessage(result);\n\t\t\t\tif(result.flag && result.flag != BICONOMY_RESPONSE_CODES.ACTION_COMPLETE\n\t\t\t\t\t&& result.flag != BICONOMY_RESPONSE_CODES.SUCCESS) {\n\t\t\t\t\tlet error = {};\n\t\t\t\t\terror.code = result.flag;\n\t\t\t\t\tif(result.flag == BICONOMY_RESPONSE_CODES.USER_CONTRACT_NOT_FOUND) {\n\t\t\t\t\t\terror.code = RESPONSE_CODES.USER_CONTRACT_NOT_FOUND;\n\t\t\t\t\t}\n\t\t\t\t\terror.message = result.log;\n\t\t\t\t\tif(cb) cb(error);\n\t\t\t\t} else {\n\t\t\t\t\tif(cb) cb(null, result.txHash);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_logMessage(response);\n\t\t\t\tif(cb) cb(formatMessage(RESPONSE_CODES.ERROR_RESPONSE, `Invalid response from api ${url}`));\n\t\t\t}\n\t      })\n\t      .catch(function(error) {\n\t        _logMessage(error);\n\t        if(cb) cb(error);\n\t      });\n\t} else {\n\t\t_logMessage(`Invalid arguments, provider: ${engine} account: ${account} api: ${api} data: ${data}`);\n\t\tif(cb) cb(`Invalid arguments, provider: ${engine} account: ${account} api: ${api} data: ${data}`, null);\n\t}\n}\n\n/**\n * Function to initialize the biconomy object with DApp information.\n * It fetches the dapp's smart contract from biconomy database and initialize the decoders for each smart\n * contract which will be used to decode information during function calls.\n * @param dappId Id for dapp whose information is to be fetched\n * @param apiKey API key used to authenticate the request at biconomy server\n * @param _this object representing biconomy provider\n **/\nasync function _init(dappId, apiKey, engine) {\n\ttry {\n\t\t// Check current network id and dapp network id registered on dashboard\n\t\tlet getDappAPI = `${baseURL}/api/${config.version}/dapp?dappId=${dappId}`;\n\t\taxios.defaults.headers.common[\"x-api-key\"] = apiKey;\n\t\taxios.get(getDappAPI).then(function(response) {\n\t\t\tlet dappResponse = response.data;\n\t\t\tif(dappResponse && dappResponse.dapp) {\n\t\t\t\tlet dappNetworkId = dappResponse.dapp.networkId;\n\t\t\t\t_logMessage(`Network id corresponding to dapp id ${dappId} is ${dappNetworkId}`);\n\t\t\t\tweb3.currentProvider.send({\n\t\t\t\t\tjsonrpc: JSON_RPC_VERSION,\n\t\t\t\t\tid: '102',\n\t\t\t\t\tmethod: 'net_version',\n\t\t\t\t\tparams: []\n\t\t\t\t}, function(error, networkResponse){\n\t\t\t\t\tif(error || (networkResponse && networkResponse.error)) {\n\t\t\t\t\t\treturn eventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\t\tformatMessage(RESPONSE_CODES.NETWORK_ID_NOT_FOUND , \"Could not get network version\"), error || networkResponse.error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet providerNetworkId = networkResponse.result;\n\t\t\t\t\t\t_logMessage(`Current provider network id: ${providerNetworkId}`);\n\t\t\t\t\t\tif(providerNetworkId != dappNetworkId) {\n\t\t\t\t\t\t\treturn eventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\t\t\tformatMessage(RESPONSE_CODES.NETWORK_ID_MISMATCH,\n\t\t\t\t\t\t\t\t`Current networkId ${providerNetworkId} is different from dapp network id registered on mexa dashboard ${dappNetworkId}`));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdomainData.chainId = providerNetworkId;\n\t\t\t\t\t\t\taxios.get(`${baseURL}/api/${config.version2}/meta-tx/systemInfo?networkId=${providerNetworkId}`)\n\t\t\t\t\t\t\t.then(signatureTypesResult => {\n\t\t\t\t\t\t\t\tif(signatureTypesResult && signatureTypesResult.data) {\n\t\t\t\t\t\t\t\t\tlet systemInfo = signatureTypesResult.data;\n\t\t\t\t\t\t\t\t\tdomainType = systemInfo.domainType;\n\t\t\t\t\t\t\t\t\tmetaInfoType = systemInfo.metaInfoType;\n\t\t\t\t\t\t\t\t\trelayerPaymentType = systemInfo.relayerPaymentType;\n\t\t\t\t\t\t\t\t\tmetaTransactionType = systemInfo.metaTransactionType;\n\t\t\t\t\t\t\t\t\tloginDomainType = systemInfo.loginDomainType;\n\t\t\t\t\t\t\t\t\tloginMessageType = systemInfo.loginMessageType;\n\t\t\t\t\t\t\t\t\tloginDomainData = systemInfo.loginDomainData;\n\n\t\t\t\t\t\t\t\t\tif(systemInfo.relayHubAddress) {\n\t\t\t\t\t\t\t\t\t\tdomainData.verifyingContract = systemInfo.relayHubAddress;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn eventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\t\t\t\t\tformatMessage(RESPONSE_CODES.INVALID_DATA ,\n\t\t\t\t\t\t\t\t\t\t\t\"Could not get signature types from server. Contact Biconomy Team\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Get dapps smart contract data from biconomy servers\n\t\t\t\t\t\t\t\tlet getDAppInfoAPI = `${baseURL}/api/${config.version}/smart-contract?dappId=${dappId}`;\n\t\t\t\t\t\t\t\taxios.get(getDAppInfoAPI).then(function(response) {\n\t\t\t\t\t\t\t\t\tlet result = response.data;\n\t\t\t\t\t\t\t\t\tif(!result && result.flag != 143) {\n\t\t\t\t\t\t\t\t\t\treturn eventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\t\t\t\t\t\tformatMessage(RESPONSE_CODES.SMART_CONTRACT_NOT_FOUND ,\n\t\t\t\t\t\t\t\t\t\t\t\t`Error getting smart contract for dappId ${dappId}`));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet smartContractList = result.smartContracts;\n\t\t\t\t\t\t\t\t\tif(smartContractList && smartContractList.length > 0) {\n\t\t\t\t\t\t\t\t\t\tsmartContractList.forEach(contract => {\n\t\t\t\t\t\t\t\t\t\t\tlet abiDecoder = require('abi-decoder');\n\t\t\t\t\t\t\t\t\t\t\tabiDecoder.addABI(JSON.parse(contract.abi));\n\t\t\t\t\t\t\t\t\t\t\tdecoderMap[contract.address.toLowerCase()] = abiDecoder;\n\t\t\t\t\t\t\t\t\t\t\tsmartContractMap[contract.address.toLowerCase()] = contract.abi;\n\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\tlet userLocalAccount = getFromStorage(USER_ACCOUNT);\n\t\t\t\t\t\t\t\t\t\tlet userLocalContract = getFromStorage(USER_CONTRACT);\n\t\t\t\t\t\t\t\t\t\tif(userLocalContract && userLocalAccount) {\n\t\t\t\t\t\t\t\t\t\t\t_getUserAccount(engine, undefined, (error, response) => {\n\t\t\t\t\t\t\t\t\t\t\t\tif(error || !response || response.error) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn eventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tformatMessage(RESPONSE_CODES.USER_ACCOUNT_NOT_FOUND ,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"Could not get user account\"));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tlet account = response.result[0];\n\t\t\t\t\t\t\t\t\t\t\t\t_getUserContractWallet(engine, account, (error, userContract) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(userContract && account && account.toUpperCase() == userLocalAccount.toUpperCase()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t&& userContract.toUpperCase() == userLocalContract.toUpperCase()) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tengine.isLogin = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t_logMessage('Biconomy user login set to true');\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\teventEmitter.emit(EVENTS.SMART_CONTRACT_DATA_READY, dappId, engine);\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\teventEmitter.emit(EVENTS.SMART_CONTRACT_DATA_READY, dappId, engine);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tengine.status = STATUS.NO_DATA;\n\t\t\t\t\t\t\t\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\t\t\t\t\t\tformatMessage(RESPONSE_CODES.SMART_CONTRACT_NOT_FOUND ,\n\t\t\t\t\t\t\t\t\t\t\t\t`No smart contract registered for dappId ${dappId} on Mexa Dashboard`));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.catch(function(error) {\n\t\t\t\t\t\t\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\t\t\t\t\tformatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Error while initializing Biconomy\"), error);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif(dappResponse.log) {\n\t\t\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\tformatMessage(RESPONSE_CODES.ERROR_RESPONSE, dappResponse.log));\n\t\t\t\t} else {\n\t\t\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\tformatMessage(RESPONSE_CODES.DAPP_NOT_FOUND, `No Dapp Registered with dapp id ${dappId}`));\n\t\t\t\t}\n\t\t\t}\n\t\t}).catch(function(error) {\n\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\tformatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Error while initializing Biconomy\"), error);\n\t\t});\n\t} catch(error) {\n\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\tformatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Error while initializing Biconomy\"), error);\n\t}\n\n}\n\n/**\n * Method to get user contract wallet from biconomy server.\n **/\nasync function _getUserContractWallet(engine, address, cb) {\n\tlet promise = new Promise((resolve, reject) => {\n\t\tif(address) {\n\t\t\tengine.sendAsync({\n\t\t\t\tjsonrpc: JSON_RPC_VERSION,\n\t\t\t\tid: '102',\n\t\t\t\tmethod: 'net_version',\n\t\t\t\tparams: []\n\t\t\t}, function(error, response){\n\t\t\t\tif(error || (response && response.error)) {\n\t\t\t\t\tconsole.error(error || response.error);\n\t\t\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR,\n\t\t\t\t\t\tformatMessage(RESPONSE_CODES.NETWORK_ID_NOT_FOUND , \"Could not get network version\"), error || networkResponse.error);\n\t\t\t\t\treject(\"Could not get network version\");\n\t\t\t\t} else {\n\t\t\t\t\tlet networkId = response.result;\n\t\t\t\t\tlet data = {owner:address, networkId: networkId};\n\t\t\t\t\taxios\n\t\t\t\t\t  .get(`${baseURL}${getUserContractPath}`, {params: data})\n\t\t\t\t\t  .then(function(response) {\n\t\t\t\t\t\tconst data = response.data;\n\t\t\t\t\t\tconsole.debug(data);\n\t\t\t\t\t\tif(data.flag && data.flag == BICONOMY_RESPONSE_CODES.SUCCESS) {\n\t\t\t\t\t\t\tif(cb) {\n\t\t\t\t\t\t\t\tcb(null, data.userContract);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresolve(data.userContract);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(cb) {\n\t\t\t\t\t\t\t\tcb(\"User contract not found\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treject(\"User contract not found\");\n\t\t\t\t\t\t}\n\t\t\t\t\t  })\n\t\t\t\t\t  .catch(function(error) {\n\t\t\t\t\t\t_logMessage(error);\n\t\t\t\t\t\tlet response = formatMessage(RESPONSE_CODES.ERROR_RESPONSE,\n\t\t\t\t\t\t\t`Error while fetching user contract ${JSON.stringify(error)}`);\n\t\t\t\t\t\tif(cb) cb(response);\n\t\t\t\t\t\treject(response);\n\t\t\t\t\t  });\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tlet response = formatMessage(RESPONSE_CODES.INVALID_DATA, \"Input address is not valid\");\n\t\t\tif(cb) cb(response);\n\t\t\treject(response);\n\t\t}\n\t});\n\treturn promise;\n}\n\n/**\n * Function used to login user. This creates a smart contract wallet for new user and\n * just returns contract wallet address for existing user.\n *\n * This function should be used when you have access to user's private key.\n *\n * @param {string} signer User Externally Owned Account (EOA) address\n * @param {string} signature EIP712 formatted signature signed using signer address\n * @param {function} cb Optional callback method with error first parameter\n *\n * @returns A promise that resolves to response containg transaction hash for new user\n * and user contract wallet address for existing user.\n *\n * Refer to https://docs.biconomy.io for more details on how to use it.\n */\nBiconomy.prototype.accountLogin = async function(signer, signature, cb) {\n\tlet engine = this;\n\treturn new Promise(async (resolve, reject) => {\n\t\tlet data = {};\n\t\tdata.signature = signature;\n\t\tdata.from = signer;\n\t\tdata.providerId = engine.providerId;\n\t\taxios\n\t\t\t.post(`${baseURL}${userLoginPath}`, data)\n\t\t\t.then(function(response) {\n\t\t\t\tconst data = response?response.data:undefined;\n\t\t\t\t_logMessage(data);\n\t\t\t\tif(data) {\n\t\t\t\t\tlet result = {}\n\t\t\t\t\tif(data.flag && data.flag == BICONOMY_RESPONSE_CODES.ACTION_COMPLETE) {\n\t\t\t\t\t\tresult.code = RESPONSE_CODES.SUCCESS_RESPONSE;\n\t\t\t\t\t\tif(data.userContract) {\n\t\t\t\t\t\t\tresult.message = `User login successfull`;\n\t\t\t\t\t\t\tresult.userContract = data.userContract;\n\t\t\t\t\t\t\tengine.isLogin = true;\n\t\t\t\t\t\t\t_setLocalData(signer, data.userContract);\n\t\t\t\t\t\t} else if(data.transactionHash) {\n\t\t\t\t\t\t\tresult.message = `User contract creation initiated`;\n\t\t\t\t\t\t\tresult.transactionHash = data.transactionHash;\n\t\t\t\t\t\t\tloginInterval = setInterval(function(){\n\t\t\t\t\t\t\t\tgetLoginTransactionReceipt(engine,data.transactionHash,signer)\n\t\t\t\t\t\t\t}, 2000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cb) cb(null, result);\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.code = RESPONSE_CODES.ERROR_RESPONSE;\n\t\t\t\t\t\tresult.message = data.log;\n\t\t\t\t\t\tif(cb) cb(result, null);\n\t\t\t\t\t\treject(result);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet error = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, `Invalid response from api ${url}`);\n\t\t\t\t\tif(cb) cb(error);\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch(function(error) {\n\t\t\t\t_logMessage(error);\n\t\t\t\tcb(error, null);\n\t\t\t\treject(error);\n\t\t\t});\n\t});\n}\n\nconst getLoginTransactionReceipt = async (engine,txHash,userAddress) => {\n    var receipt = await web3.eth.getTransactionReceipt(txHash);\n    if(receipt){\n      \tif(receipt.status){\n        \tawait _getUserContractWallet(engine, userAddress, (error, userContract) => {\n\t\t\t\tif(!error && userContract) {\n\t\t\t\t\t_setLocalData(userAddress, userContract);\n\t\t\t\t\tengine.isLogin = true;\n\t\t\t\t\teventEmitter.emit(EVENTS.LOGIN_CONFIRMATION, \"User Contract wallet created Successfully\", userContract);\n\t\t\t\t}\n\t\t\t});\n      \t}\n      \telse if(!receipt.status){\n\t\t\teventEmitter.emit(EVENTS.BICONOMY_ERROR,formatMessage(RESPONSE_CODES.USER_CONTRACT_CREATION_FAILED,\"User Contract wallet creation Failed\"));\n      \t}\n      \tif(loginInterval){\n        \tclearInterval(loginInterval);\n      \t}\n    }\n}\n\nBiconomy.prototype.isReady = function() {\n\treturn (this.status === STATUS.BICONOMY_READY);\n}\n\n/**\n * Method used to login to biconomy. It takes user's public address as input\n * and if user contract wallet is not found for the user then it deploys\n * new user contract for the user. It user contract already exists it just\n * resolve to the contract wallet address.\n *\n * @returns Promise object that resolve to either transactionHash info or Contract wallet address\n **/\nBiconomy.prototype.login = async function(signer, cb){\n\treturn new Promise(async (resolve, reject)=> {\n\t\tif(!signer || typeof signer != 'string') {\n\t\t\tlet response = formatMessage(RESPONSE_CODES.INVALID_DATA, \"signer parameter is mandatory and should be of type 'string'\");\n\t\t\tif(cb) cb(response);\n\t\t\treject(response);\n\t\t\treturn;\n\t\t}\n\t\tlet engine = this;\n\t\tlet message = {};\n\t\tmessage.userAddress = signer.toLowerCase();\n\t\tmessage.providerId = engine.providerId\n\t\tlet nonce = await _getUserNonce(signer, this);\n\t\tif(!nonce) {\n\t\t\tnonce = 0;\n\t\t}\n\t\tmessage.nonce = nonce;\n\n\t\tconst dataToSign = JSON.stringify({\n\t\t\ttypes: {\n\t\t\t\tEIP712Domain: loginDomainType,\n\t\t\t\tLoginMessage: loginMessageType\n\t\t\t},\n\t\t\tdomain: loginDomainData,\n\t\t\tprimaryType: \"LoginMessage\",\n\t\t\tmessage: message\n\t\t});\n\n\t\tconsole.debug(`Biconomy engine status ${engine.status}`);\n\t\tif(engine.status != STATUS.BICONOMY_READY) {\n\t\t\treturn cb(formatMessage(RESPONSE_CODES.BICONOMY_NOT_INITIALIZED,'Biconomy SDK is not initialized properly'));\n\t\t}\n\t\tweb3.currentProvider.sendAsync({\n\t\t\tjsonrpc: JSON_RPC_VERSION,\n\t\t\tid: '101',\n\t\t\tmethod: config.signTypedV3Method,\n\t\t\tparams: [signer, dataToSign]\n\t\t}, function(error, signature){\n\t\t\tif(error) {\n\t\t\t\tlet response = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, error);\n\t\t\t\tif(cb) cb(response);\n\t\t\t\treject(response);\n\t\t\t} else {\n\t\t\t\tlet data = {};\n\t\t\t\tdata.signature = signature.result;\n\t\t\t\tdata.from = signer;\n\t\t\t\tdata.providerId = engine.providerId;\n\t\t\t\taxios\n\t\t\t\t.post(`${baseURL}${userLoginPath}`, data)\n\t\t\t\t.then(function(response) {\n\t\t\t\t\tconst data = response.data;\n\t\t\t\t\tconsole.debug(data);\n\t\t\t\t\tlet result = {}\n\t\t\t\t\tif(data.flag && data.flag == BICONOMY_RESPONSE_CODES.ACTION_COMPLETE) {\n\t\t\t\t\t\tresult.code = RESPONSE_CODES.SUCCESS_RESPONSE;\n\t\t\t\t\t\tif(data.userContract) {\n\t\t\t\t\t\t\tresult.message = `User login successfull`;\n\t\t\t\t\t\t\tresult.userContract = data.userContract;\n\t\t\t\t\t\t\tengine.isLogin = true;\n\t\t\t\t\t\t\t_setLocalData(signer, data.userContract);\n\t\t\t\t\t\t} else if(data.transactionHash) {\n\t\t\t\t\t\t\tresult.message = `User contract creation initiated`;\n\t\t\t\t\t\t\tresult.transactionHash = data.transactionHash;\n\t\t\t\t\t\t\tloginInterval = setInterval(function(){\n\t\t\t\t\t\t\t\tgetLoginTransactionReceipt(engine,data.transactionHash,signer)\n\t\t\t\t\t\t\t}, 2000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cb) cb(null, result);\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.code = RESPONSE_CODES.ERROR_RESPONSE;\n\t\t\t\t\t\tresult.message = data.log;\n\t\t\t\t\t\tif(cb) cb(result, null);\n\t\t\t\t\t\treject(result);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.catch(function(error) {\n\t\t\t\t\tconsole.debug(error);\n\t\t\t\t\tlet response = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, error);\n\t\t\t\t\tif(cb) cb(response);\n\t\t\t\t\treject(response);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n};\n\n/**\n * Function used to logout user from biconomy. It clears any internal user state and local storage.\n */\nBiconomy.prototype.logout = function() {\n\tremoveFromStorage(USER_ACCOUNT);\n\tremoveFromStorage(USER_CONTRACT);\n\tthis.isLogin = false;\n}\n\n/**\n * Function to return user contract wallet address.\n *\n * @param {string} userAddress User address for which contract wallet is requested\n * @returns A promise that resolves to user contact wallet if it exists else error response.\n */\nBiconomy.prototype.getUserContract = async function(userAddress) {\n\tlet response;\n\tif(this.isLogin) {\n\t\tlet userAddressFromStorage = getFromStorage(USER_ACCOUNT);\n\t\tif(userAddressFromStorage && userAddress){\n\t\t\tif( userAddressFromStorage.toLowerCase() === userAddress.toLowerCase()) {\n\t\t\t\tresponse = formatMessage(RESPONSE_CODES.SUCCESS_RESPONSE, \"User Contract Wallet address fetched successfully\");\n\t\t\t\tresponse.userContract = getFromStorage(USER_CONTRACT);\n\t\t\t}\n\t\t\tif(!response) {\n\t\t\t\tlet userContract = await _getUserContractWallet(this, userAddress);\n\t\t\t\tif(userContract) {\n\t\t\t\t\tresponse = formatMessage(RESPONSE_CODES.SUCCESS_RESPONSE, \"User Contract Wallet address fetched successfully\");\n\t\t\t\t\tresponse.userContract = userContract;\n\t\t\t\t} else {\n\t\t\t\t\tresponse = formatMessage(RESPONSE_CODES.ERROR_RESPONSE, \"Unable to fetch User Contract Wallet\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tresponse = formatMessage(RESPONSE_CODES.USER_NOT_LOGGED_IN, \"Please login to biconomy first\");\n\t}\n\treturn response;\n}\n\nBiconomy.prototype.getUserAccount = async function() {\n\treturn await _getUserAccount(this);\n}\n\nfunction formatMessage(code, message) {\n\treturn {\n\t\tcode: code,\n\t\tmessage: message\n\t};\n}\n\n/**\n * Setting data in localstorage to check later if user contract and user account\n * already exists and user has already logged in to biconomy once.\n **/\nfunction _setLocalData(signer, userContract) {\n\tif(typeof localStorage != 'undefined') {\n\t\tif(signer && userContract) {\n\t\t\tlocalStorage.setItem(USER_ACCOUNT, signer);\n\t\t\tlocalStorage.setItem(USER_CONTRACT, userContract);\n\t\t}\n\t} else {\n\t\tthis[USER_ACCOUNT] = signer;\n\t\tthis[USER_CONTRACT] = userContract;\n\t}\n}\n\n\nfunction removeFromStorage(key) {\n\tif(typeof localStorage != 'undefined') {\n\t\tlocalStorage.removeItem(key);\n\t} else {\n\t\tthis[key] = null;\n\t}\n}\n\nfunction getFromStorage(key) {\n\tif(typeof localStorage != 'undefined') {\n\t\treturn localStorage.getItem(key);\n\t} else {\n\t\treturn this[key];\n\t}\n}\n\n/**\n * Single method to be used for logging purpose.\n *\n * @param {string} message Message to be logged\n */\nfunction _logMessage(message) {\n\tif(config && config.logsEnabled && console.log) {\n\t\tconsole.log(message);\n\t}\n}\n\nvar scientificToDecimal = function (num) {\n    var nsign = Math.sign(num);\n    //remove the sign\n    num = Math.abs(num);\n    //if the number is in scientific notation remove it\n    if (/\\d+\\.?\\d*e[\\+\\-]*\\d+/i.test(num)) {\n        var zero = '0',\n                parts = String(num).toLowerCase().split('e'), //split into coeff and exponent\n                e = parts.pop(), //store the exponential part\n                l = Math.abs(e), //get the number of zeros\n                sign = e / l,\n                coeff_array = parts[0].split('.');\n        if (sign === -1) {\n            l = l - coeff_array[0].length;\n            if (l < 0) {\n              num = coeff_array[0].slice(0, l) + '.' + coeff_array[0].slice(l) + (coeff_array.length === 2 ? coeff_array[1] : '');\n            }\n            else {\n              num = zero + '.' + new Array(l + 1).join(zero) + coeff_array.join('');\n            }\n        }\n        else {\n            var dec = coeff_array[1];\n            if (dec)\n                l = l - dec.length;\n            if (l < 0) {\n\t\t\t  num\n\t\t\t  = coeff_array[0] + dec.slice(0, l) + '.' + dec.slice(l);\n            } else {\n              num = coeff_array.join('') + new Array(l + 1).join(zero);\n            }\n        }\n    }\n    return nsign < 0 ? '-'+num : num;\n};\n\nmodule.exports = Biconomy\n"]},"metadata":{},"sourceType":"script"}